
=encoding utf8

=head1 NAME

Sidef::Types::Array::Array

=head1 DESCRIPTION

This class implements ...

=head1 SYNOPSIS

var obj = Array(...)


=head1 INHERITS

Inherits methods from:

       * Sidef::Object::Object

=head1 METHODS

=head2 &

    a & b

Returns the intersection of two arrays.

    <a a a b c> & <a x y a c>    #=> ["a", "a", "c"]

Aliases: I<and>

=cut

=head2 *

    a * n

Repeats the content of array C<a> n times, returning a new array.

    <a b> * 2   #=> ["a", "b", "a", "b"]

Aliases: I<mul>

=cut

=head2 **

    a ** n

Matrix exponentiation, excpecting array C<a> to be a 2D array.

    var A = [[1, 2, 0],
             [0, 3, 1],
             [1, 0, 0]]

    say A**5     #=> [[37, 274, 84], [42, 311, 95], [11, 84, 26]]

Aliases: I<mpow>, I<matrix_pow>

=cut

=head2 +

    a + b

Array concatenation, returning a new array.

    <a b> + <c d>    #=> ["a", "b", "c", "d"]

Aliases: I<add>, I<concat>

=cut

=head2 -

    a - b

Array difference: removes any element from array C<a> that exists inside array C<b>, returning a new array.

    <a a a b c> - <a x y a c>       #=> ["a", "b"]

Aliases: I<sub>, I<diff>

=cut

=head2 ...

    a...

Converts array C<a> into a list.

    var (a,b,c) = <1 2 3>...

Aliases: I<to_list>

=cut

=head2 /

    a / n

Divides the array C<a> into C<n> segments.

If the division is not exact, the remaining incomplete segment is added to the end of the returned array.

    <a b c d>   / 2     #=> [["a", "b"], ["c", "d"]]
    <a b c d e> / 2     #=> [["a", "b"], ["c", "d"], ["e"]]

Aliases: I<÷>, I<div>

=cut

=head2 <

    a < b

Less-than array comparison, done term-by-term, returning C<true> or C<false>.

Aliases: I<lt>

=cut

=head2 <=>

    a <=> b

Array comparison, done term-by-term, returning:

     1 when a > b
     0 when a == b
    -1 when a < b

Aliases: I<cmp>

=cut

=head2 ==

    a == b

Returns true if C<a> and C<b> are equal to each other.

Aliases: I<eq>

=cut

=head2 >

    a > b

Greater-than array comparison, done term-by-term, returning C<true> or C<false>.

Aliases: I<gt>

=cut

=head2 ^

    a ^ b

Returns the set difference of two arrays.

    <a a a b c> ^ <a x y a c>   #=> ["a", "b", "x", "y"]

Aliases: I<xor>

=cut

=head2 |

    a | b

Returns the union of two arrays.

    <a a a b c> | <a x y a c>   #=> ["a", "a", "a", "b", "c", "x", "y"]

Aliases: I<or>

=cut

=head2 |>>

    a |>> b

Returns the

Aliases: I<pipeline_map_op>

=cut

=head2 |X>

    a |X> (block1, block2, ...)

Pipeline cross-product operator, mapping each element to each given block.

   say ([1,2,3] |X> ({ .cube }, { _+42 }))     #=> [1, 43, 8, 44, 27, 45]

Aliases: I<pipeline_cross_op>

=cut

=head2 |Z>

    Array.|Z>()

Returns the

Aliases: I<pipeline_zip_op>

=cut

=head2 «

    a « b

Returns the

Aliases: I<E<lt>E<lt>>, I<push>, I<append>

=cut

=head2 »

    a » b

Returns the

Aliases: I<E<gt>E<gt>>, I<pop>, I<drop_last>, I<drop_right>

=cut

=head2 ∋

    a ∋ b

Returns the

Aliases: I<has>, I<contain>, I<include>, I<contains>, I<includes>

=cut

=head2 ∌

    a ∌ b

Returns the

=cut

=head2 ≠

    a ≠ b

Returns the

Aliases: I<!=>, I<ne>

=cut

=head2 ≤

    a ≤ b

Returns the

Aliases: I<E<lt>=>, I<le>

=cut

=head2 ≥

    a ≥ b

Returns the

Aliases: I<E<gt>=>, I<ge>

=cut

=head2 abbrev

    arr.abbrev
    arr.abbrev(/pattern/)

Returns an Hash with the unambiguous abbreviations for the given array of strings.

    say ['loved', 'loving', 'lover', 'lost'].abbrev

Output:

    Hash(
        "los"    => "lost",
        "lost"   => "lost",
        "loved"  => "loved",
        "lover"  => "lover",
        "lovi"   => "loving",
        "lovin"  => "loving",
        "loving" => "loving"
    )

When an additionaly regular expression is given, it collects only the abbreviations that will match the regex.

Aliases: I<abbreviations>

=cut

=head2 acc

    Array.acc()

Returns the

Aliases: I<accumulate>

=cut

=head2 acc_by

    Array.acc_by()

Returns the

Aliases: I<accumulate_by>

=cut

=head2 all

    Array.all()

Returns the

=cut

=head2 all_composite

    Array.all_composite()

Returns the

=cut

=head2 all_prime

    Array.all_prime()

Returns the

=cut

=head2 any

    Array.any()

Returns the

=cut

=head2 avg

    arr.avg

Returns the average of a list of numbers.

    say [1,2,3,4].avg   #=> 2.5

=cut

=head2 avg_by

    arr.avg_by { ... }

Returns the average of a list of numbers, by mapping each value to a given block of code.

    say [1,2,3,4].avg_by { _**2 }   #=> 7.5

=cut

=head2 bindex

    arr.bindex(obj)

Returns the index of a given element inside a sorted array, using the I<Binary Search> algorithm.

    var a = ["Alice", "Jane", "Joe", "John", "Kate", "Zerg"]

    say a.bindex('Alice')   #=> 0 (first index)
    say a.bindex('Jane')    #=> 1 (second index)

Aliases: I<bsearch_index>

=cut

=head2 bindex_by

    arr.bindex_by { ... }

Returns the index of any element inside a sorted array, based on a given comparison block, using the I<Binary Search> algorithm.

    var a = ["Alice", "Jane", "Joe", "John", "Kate", "Zerg"]

    say a.bindex { _ <=> 'Joe' }     #=> 2 (third index)
    say a.bindex { _ <=> 'John' }    #=> 3 (fourth index)

Aliases: I<bsearch_index_by>

=cut

=head2 bindex_ge

    Array.bindex_ge()

Returns the

=cut

=head2 bindex_ge_by

    Array.bindex_ge_by()

Returns the

=cut

=head2 bindex_le

    Array.bindex_le()

Returns the

=cut

=head2 bindex_le_by

    Array.bindex_le_by()

Returns the

=cut

=head2 binsert

    arr.binsert(obj)

Inserts an element into a sorted array, such that the array will still be sorted.

    var a = ['a', 'b', 'd']
    a.binsert('c')                  # inserts 'c' before 'd'
    say a                           # prints: ['a', 'b', 'c', 'd']

Modifies the array in-place.

=cut

=head2 binsplit

    arr.binsplit {|a,b| ... }

Applies the binary splitting algorithm to the self-array, returning the result computed using the given block of code.

    say [1,2,3,4,5].binsplit {|a,b| a*b }   #=> 120

=cut

=head2 bsearch

    Array.bsearch()

Returns the

Aliases: I<bsearch_by>

=cut

=head2 bsearch_ge

    Array.bsearch_ge()

Returns the

Aliases: I<bsearch_ge_by>

=cut

=head2 bsearch_le

    Array.bsearch_le()

Returns the

Aliases: I<bsearch_le_by>

=cut

=head2 bshuffle

    arr.bshuffle

Shuffles an array in such a way that no element will be on the same position as in the original array (if possible).

Aliases: I<best_shuffle>

=cut

=head2 cartesian

    arr.cartesian
    arr.cartesian {|*c| ... }

Returns the Cartesian product of a 2D array.

    say [[1,2],[3,4]].cartesian    #=> [[1,3], [1,4], [2,3], [2,4]]

When a block is given, it gets called which each combination:

    [[1,2],[3,4],[5,6]].cartesian {|*c| say c }

Output:

    [1, 3, 5]
    [1, 3, 6]
    [1, 4, 5]
    [1, 4, 6]
    [2, 3, 5]
    [2, 3, 6]
    [2, 4, 5]
    [2, 4, 6]

=cut

=head2 cfrac2num

    arr.cfrac2num

Converts a given continued fraction expansion to a number.

    var c = Num.pi.cfrac(10)    # [3, 7, 15, 1, 292, 1, 1, 1, 2, 1]
    say c.cfrac2num.as_frac     #=> 4272943/1360120

=cut

=head2 change_to

    Array.change_to()

Returns the

=cut

=head2 chrs

    Array.chrs()

Returns the

Aliases: I<decode>, I<join_bytes>

=cut

=head2 circular_permutations

    Array.circular_permutations()

Returns the

=cut

=head2 clear

    Array.clear()

Returns the

=cut

=head2 collapse

    Array.collapse()

Returns the

=cut

=head2 combinations

    Array.combinations()

Returns the

=cut

=head2 combinations_with_repetition

    Array.combinations_with_repetition()

Returns the

=cut

=head2 combine

    Array.combine()

Returns the

=cut

=head2 compact

    Array.compact()

Returns the

=cut

=head2 cons

    arr.cons(n)

Returns a new array of arrays with n-consecutive elements from the self-array.

    say [1,2,3,4].cons(2)      #=> [[1, 2], [2, 3], [3, 4]]

Aliases: I<map_cons>

=cut

=head2 contains_all

    Array.contains_all()

Returns the

=cut

=head2 contains_any

    Array.contains_any()

Returns the

=cut

=head2 contains_type

    Array.contains_type()

Returns the

=cut

=head2 count

    Array.count()

Returns the

=cut

=head2 count_by

    Array.count_by()

Returns the

=cut

=head2 cross_op

    Array.cross_op()

Returns the

Aliases: I<cross_operator>

=cut

=head2 defined

    Array.defined()

Returns the

=cut

=head2 delete

    Array.delete()

Returns the

Aliases: I<remove>

=cut

=head2 delete_by

    Array.delete_by()

Returns the

Aliases: I<delete_if>, I<remove_by>, I<remove_if>

=cut

=head2 delete_first

    Array.delete_first()

Returns the

Aliases: I<remove_first>

=cut

=head2 delete_first_by

    Array.delete_first_by()

Returns the

Aliases: I<delete_first_if>, I<remove_first_by>, I<remove_first_if>

=cut

=head2 delete_last

    arr.delete_last(obj)

Removes the last C<obj> element from the array, modifying the array in-place.

    var arr = %w[a b c a]
    arr.delete_last('a')
    say arr                 #=> ["a", "b", "c"]

Returns true if such an element was removed.

Aliases: I<remove_last>

=cut

=head2 delete_last_by

    Array.delete_last_by()

Returns the

Aliases: I<delete_last_if>, I<remove_last_by>, I<remove_last_if>

=cut

=head2 derangements

    Array.derangements()

Returns the

Aliases: I<complete_permutations>

=cut

=head2 det

    Array.det()

Returns the

Aliases: I<determinant>

=cut

=head2 det_bareiss

    Array.det_bareiss()

Returns the

=cut

=head2 diffs

    arr.diffs(n=1)

Returns the n-th differences of the array (calling C<sub>).

    var a = [43, 97, 128, 999]

    say a.diffs                     #=> [54, 31, 871]
    say a.diffs(2)                  #=> [-23, 840]
    say a.diffs(3)                  #=> [863]

Aliases: I<differences>, I<nth_differences>

=cut

=head2 dig

    Array.dig()

Returns the

=cut

=head2 digits2num

    arr.digits2num(base=10)

Converts the list of values returned by Number C<digits(n, base)> back to C<n>.

    say 1234.digits.digits2num              #=> 1234
    say [73, 56, 0, 76, 22].digits2num(100) #=> 2276005673

Aliases: I<from_digits>

=cut

=head2 each_2d

    arr.each_2d {|a,b,c,...| ... }

Iterate over a 2D array.

    [[1,2],[3,4]].each_2d {|a,b|
        say (a**2 + b**2)
    }

=cut

=head2 each_cons

    arr.each_cons(n, { ... })

Iterate over C<n> consecutive values at a time.

    [1,2,3,4,5,6,7].each_cons(3, {|*c| say c })

Outputs:

    [1, 2, 3]
    [2, 3, 4]
    [3, 4, 5]
    [4, 5, 6]
    [5, 6, 7]

=cut

=head2 each_k

    Array.each_k()

Returns the

Aliases: I<each_key>, I<each_index>

=cut

=head2 each_kv

    Array.each_kv()

Returns the

=cut

=head2 each_slice

    Array.each_slice()

Returns the

=cut

=head2 end

    Array.end()

Returns the

Aliases: I<offset>

=cut

=head2 exists

    Array.exists()

Returns the

Aliases: I<has_index>

=cut

=head2 expand

    arr.expand { ... }

Recursively expand an array, given a block of code.

    say [1,[2,[3,4]],5].expand { _ }    #=> [1, 5, 2, 3, 4]

Aliases: I<expand_by>

=cut

=head2 extract_by

    Array.extract_by()

Returns the

=cut

=head2 extract_first_by

    Array.extract_first_by()

Returns the

=cut

=head2 extract_last_by

    Array.extract_last_by()

Returns the

=cut

=head2 fetch

    arr.fetch(index, default)

Fetches a value at the given index. When the index does not exist, it returns the default value.

    var a = [3,9,27]
    say a.fetch(2, 42)     # fetches index 2 and prints: 27
    say a.fetch(3, 42)     # fails to fetch index 3, therefore prints: 42

=cut

=head2 find

    Array.find()

Returns the

Aliases: I<first_by>

=cut

=head2 flat

    Array.flat()

Returns the

Aliases: I<flatten>

=cut

=head2 flat_map

    arr.flat_map { ... }

Similar to C<.map{}>, but it expects the returned block-value to be an array, which will be collected as a list.

    say [1,2,3,4,5].flat_map { .factor }      #=> [2, 3, 2, 2, 5]

=cut

=head2 flip

    Array.flip()

Returns the

Aliases: I<reverse>

=cut

=head2 for

    Array.for()

Returns the

Aliases: I<each>, I<foreach>

=cut

=head2 freq

    arr.freq

Returns a frequency Hash for the elements inside the array.

    say ["a","b","a"].freq      #=> Hash(a => 2, b => 1)

=cut

=head2 freq_by

    Array.freq_by()

Returns the

=cut

=head2 ft

    Array.ft()

Returns the

Aliases: I<slice>

=cut

=head2 gauss_jordan_invert

    Array.gauss_jordan_invert()

Returns the

=cut

=head2 gauss_jordan_solve

    Array.gauss_jordan_solve()

Returns the

=cut

=head2 gcd

    Array.gcd()

Returns the

=cut

=head2 gcd_by

    Array.gcd_by()

Returns the

=cut

=head2 gcud

    Array.gcud()

Returns the

=cut

=head2 gcud_by

    Array.gcud_by()

Returns the

=cut

=head2 getopt

    arr.getopt(...)

Parse an array containing (long) command-line arguments, automatically converting the argument-values based on the types of the default values.

    var file = File('file.dat')
    var length = 42
    var verbose = false

    var args = ['--file', 'foo.txt', '--length', '1234', '--verbose']

    args.getopt(
        'length=i' => \length,
        'file=s'   => \file,
        'verbose!' => \verbose,
    )

    say file.dump           #=> File("foo.txt")
    say length              #=> 1234
    say verbose             #=> true

=cut

=head2 grep

    Array.grep()

Returns the

Aliases: I<select>

=cut

=head2 grep_2d

    arr.grep_2d {|a,b,c,...| ... }

Filtering of a 2D array, given a block of code.

    say [[1,2],[3,4]].grep_2d {|a,b| a+b == 7 }    #=> [[3,4]]

=cut

=head2 grep_kv

    Array.grep_kv()

Returns the

Aliases: I<select_kv>

=cut

=head2 group

    Array.group()

Returns the

Aliases: I<group_by>

=cut

=head2 head

    Array.head()

Returns the

Aliases: I<first>

=cut

=head2 index

    arr.index(obj)
    arr.index { ... }

Returns the first index of a given item inside the array.

    say %w(a b c).index("a")   #=> 0
    say %w(a b c).index("c")   #=> 2

When a block is given, it returns the first index of the element for which the block returns a true value:

    say %w(A B C).index { .lc == 'b' }   #=> 1

Aliases: I<index_by>, I<first_index>, I<first_index_by>

=cut

=head2 inject

    arr.inject {|a,b| ... }
    arr.inject({|a,b| ... }, obj)

Reduce a given array to a single element, given a block of code that is called with a pair C<a,b>, where C<a> is the previous result returned by the block and C<b> is the current element of the array.

The initial value of C<a> is the first element of the array.

    say [1,2,3,4].reduce {|a,b| a + b }        #=> 10

When an additional argument is given, it will be used as the initial value for C<a>:

    say [1,2,3,4].reduce({|a,b| a + b }, 5)    #=> 15

Aliases: I<reduce>

=cut

=head2 insert

    Array.insert()

Returns the

=cut

=head2 inv

    Array.inv()

Returns the

Aliases: I<invert>, I<inverse>

=cut

=head2 is_empty

    Array.is_empty()

Returns the

=cut

=head2 item

    Array.item()

Returns the

=cut

=head2 items

    Array.items()

Returns the

=cut

=head2 iter

    Array.iter()

Returns the

=cut

=head2 jaro_distance

    Array.jaro_distance()

Returns the

=cut

=head2 join

    Array.join()

Returns the

=cut

=head2 join_insert

    arr.join_insert(obj)

Inserts the given object between every element of the array. Returns a new array.

    say [1,2,3,4].join_insert(0)    #=> [1, 0, 2, 0, 3, 0, 4]

=cut

=head2 keys

    arr.keys

Returns an array with the indices of the self-array.

    say ["x","y","z"].keys   #=> [0, 1, 2]

Aliases: I<indices>

=cut

=head2 keys_by

    arr.keys_by { ... }

Returns an array with the indices for which the given block returns a true value.

    say [41, 42, 43].indices_by { .is_prime }     #=> [0, 2]

Aliases: I<indices_by>

=cut

=head2 keys_of

    arr.keys_of(obj)

Returns an array with the indices of C<obj> inside the self-array.

     say [1,2,3,1,4,1].indices_of(1)         #=> [0, 3, 5]

Aliases: I<indices_of>

=cut

=head2 kv

    Array.kv()

Returns the

Aliases: I<pairs>, I<zip_indices>

=cut

=head2 last

    Array.last()

Returns the

Aliases: I<tail>

=cut

=head2 last_by

    Array.last_by()

Returns the

=cut

=head2 last_uniq

    Array.last_uniq()

Returns the

Aliases: I<last_unique>

=cut

=head2 last_uniq_by

    Array.last_uniq_by()

Returns the

Aliases: I<last_unique_by>

=cut

=head2 lcm

    Array.lcm()

Returns the

=cut

=head2 lcm_by

    Array.lcm_by()

Returns the

=cut

=head2 len

    Array.len()

Returns the

Aliases: I<size>, I<length>

=cut

=head2 lev

    Array.lev()

Returns the

Aliases: I<leven>, I<levenshtein>

=cut

=head2 madd

    Array.madd()

Returns the

Aliases: I<matrix_add>

=cut

=head2 make

    Array.make()

Returns the

=cut

=head2 make_by

    Array.make_by()

Returns the

=cut

=head2 map

    Array.map()

Returns the

Aliases: I<collect>

=cut

=head2 map_2d

    arr.map_2d {|a,b,c,...| ... }

Mapping of a 2D array, given a block of code.

    say [[1,2],[3,4]].map_2d {|a,b| [a**2, b**2] }   #=> [[1, 4], [9, 16]]

=cut

=head2 map_kv

    Array.map_kv()

Returns the

Aliases: I<collect_kv>

=cut

=head2 map_op

    Array.map_op()

Returns the

Aliases: I<map_operator>

=cut

=head2 map_reduce

    arr.map_reduce {|a,b| ... }

Behaves almost like the C<reduce> method, except that all the intermediary terms are returned as an array.

    say [1,2,3,4,5].map_reduce {|a,b| a+b }         #=> [1, 3, 6, 10, 15]
    say [1,2,3,4,5].map_reduce {|a,b| a*b }         #=> [1, 2, 6, 24, 120]

Aliases: I<reduce_map>

=cut

=head2 match

    arr.match(/regex/)

Recursively match an array against a regular expression.

    say ['a', ['foo'], 'b'].match(/^foo/)

=cut

=head2 max

    Array.max()

Returns the

=cut

=head2 max_by

    Array.max_by()

Returns the

=cut

=head2 mdiv

    Array.mdiv()

Returns the

Aliases: I<matrix_div>

=cut

=head2 min

    Array.min()

Returns the

=cut

=head2 min_by

    Array.min_by()

Returns the

=cut

=head2 minmax

    Array.minmax()

Returns the

=cut

=head2 mmul

    a `mmul` b

Multiply two 2D-matrices, returing a Matrix object.

Example:

    say ([[1, 2],
          [3, 4]] `mmul` [[-3, -8, 3],
                          [-2,  1, 4]])

Output:

    Matrix(
        [-7, -6, 11],
        [-17, -20, 25]
    )

Aliases: I<matrix_mul>

=cut

=head2 msolve

    Array.msolve()

Returns the

Aliases: I<matrix_solve>

=cut

=head2 msub

    Array.msub()

Returns the

Aliases: I<matrix_sub>

=cut

=head2 new

    Array.new()

Returns the

Aliases: I<call>

=cut

=head2 next_permutation

    arr.next_permutation

It modifies the self array in place to contain the next unique permutation and returns true if there are more permutations available, or false if the current permutation is the last one.

Example:

    var arr = [1,1,2]
    do { say arr } while arr.next_permutation

Output:

    [1, 1, 2]
    [1, 2, 1]
    [2, 1, 1]

=cut

=head2 none

    arr.none { ... }

Returns true if none of the elements satisfy the condition given in the block of code.

    say [2, 4, 6].none { .is_odd }  #=> true

=cut

=head2 nth_perm

    arr.nth_perm(n)

Efficiently returns the n-th permuation of the self array.

    say nth_perm([0,1,2,3,4,5,6,7,8,9], 10**6)

Aliases: I<nth_permutation>

=cut

=head2 pack

    Array.pack()

Returns the

=cut

=head2 pair_map

    Array.pair_map()

Returns the

Aliases: I<pairmap>

=cut

=head2 pam_op

    arr.pam_op(operator, obj)

Reversed-mapping of the array, given an operator.

    say [1,2,3].pam_operator('/', 10)   # [10/1, 10/2, 10/3]

This method is used internally by the C<«OP«> hyper-operator:

    say ([1,2,3] «/« 10)

Aliases: I<pam_operator>

=cut

=head2 part

    arr.part(n)

Partition the array into two parts, given an index:

    [1,2,3,4,5].part(3)     # returns: ([1, 2, 3], [4, 5])
    [1,2,3,4,5].part(2)     # returns: ([1, 2], [3, 4, 5])

Negative indices are supported as well:

    [1,2,3,4,5].part(-1)    # returns: ([1, 2, 3, 4], [5])

Aliases: I<partition>

=cut

=head2 partitions

    Array.partitions()

Returns the

=cut

=head2 perm2num

    Array.perm2num()

Returns the

=cut

=head2 permutations

    Array.permutations()

Returns the

=cut

=head2 pick

    Array.pick()

Returns the

=cut

=head2 pop_at

    Array.pop_at()

Returns the

Aliases: I<delete_at>, I<delete_index>

=cut

=head2 pop_rand

    Array.pop_rand()

Returns the

=cut

=head2 pop_while

    Array.pop_while()

Returns the

=cut

=head2 prepend

    Array.prepend()

Returns the

Aliases: I<unshift>

=cut

=head2 prod

    Array.prod()

Returns the

=cut

=head2 prod_2d

    arr.prod_2d {|a,b,c,...| ... }

Product of a 2D array, by mapping each row to the given block.

    say [[2,4],[3,2],[5,1],[7,1]].prod_2d {|p,k| p**k }    #=> 5040

=cut

=head2 prod_by

    arr.prod_by { ... }

Product of an array, by mapping each element to the given block.

    say [1,2,3,4].prod_by {|n| n**3 }    # product of each element cubed

=cut

=head2 prod_kv

    Array.prod_kv()

Returns the

=cut

=head2 rand

    Array.rand()

Returns the

Aliases: I<sample>

=cut

=head2 rand_perm

    arr.rand_perm

Returns a random permutation of the self array.

Example:

    var arr = %w(a b c d e f g)
    say arr.random_permutation

Additionally, by setting a seed value for C<irand> with Number C<iseed()>, the results returned by C<random_permutation> can be reproduced.

Example with iseed():

    iseed(42)
    var arr = %w(a b c d e f g)
    say arr.random_permutation      #=> ["d", "f", "g", "b", "c", "e", "a"]

Aliases: I<random_permutation>

=cut

=head2 range

    Array.range()

Returns the

=cut

=head2 recmap

    arr.recmap { ... }

Recursively map the value of an array, given a block of code.

    # Generate all the 5-smooth numbers <= 20
    var (a, k, L) = ([1], 5, 20)
    k.primes.each {|p| a.recmap! {|n| n*p <= L ? [n*p] : () } }
    say a.sort    #=> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20]

=cut

=head2 reduce_op

    Array.reduce_op()

Returns the

Aliases: I<reduce_operator>

=cut

=head2 resize

    arr.resize(index)

Efficienlty resize the array to a given index, modifying the array in-place.

    var arr = %w[a b c d e]
    arr.resize(2)            # removes indices > 2
    say arr                  # ['a', 'b', 'c']

Use index C<-1> to empty the array.

Aliases: I<resize_to>

=cut

=head2 rindex

    Array.rindex()

Returns the

Aliases: I<rindex_by>, I<last_index>, I<last_index_by>

=cut

=head2 rotate

    Array.rotate()

Returns the

=cut

=head2 rref

    Array.rref()

Returns the

Aliases: I<reduced_row_echelon_form>

=cut

=head2 rscalar_op

    Array.rscalar_op()

Returns the

Aliases: I<rscalar_operator>

=cut

=head2 run_length

    arr.run_length
    arr.run_length { ... }

The run-length algorithm, returning an array of pairs C<[a,n]>.

    say [1,1,1,2,3,3].run_length            #=> [[1, 3], [2, 1], [3, 2]]
    say %w(a a b C c c).run_length { .lc }  #=> [['a', 2], ['b', 1], ['C', 3]]

Aliases: I<run_length_by>

=cut

=head2 sadd

    Array.sadd()

Returns the

Aliases: I<scalar_add>

=cut

=head2 scalar_op

    Array.scalar_op()

Returns the

Aliases: I<scalar_operator>

=cut

=head2 sdiv

    Array.sdiv()

Returns the

Aliases: I<scalar_div>

=cut

=head2 segment

    arr.segment(indices...)

Segment an array at the given indices.

    var arr = [1,2,3,4]
    say arr.segment(1)         #=> [[1, 2], [3, 4]]
    say arr.segment(2)         #=> [[1, 2, 3], [4]]
    say arr.segment(0, 1, 2)   #=> [[1], [2], [3], [4]]
    say arr.segment(0, 2)      #=> [[1], [2, 3], [4]]

Negative indices can be used for couting from the end of the array (e.g.: -1 means the end of the array).

=cut

=head2 segment_by

    arr.segment_by { ... }

Segment the array into multiple sub-arrays, whenever the block returns a true value.

Example:

    # Segment the array after each prime number
    say @(1..prime(5)).segment_by { .is_prime }

Output:

    [[1, 2], [3], [4, 5], [6, 7], [8, 9, 10, 11]]

=cut

=head2 shift

    Array.shift()

Returns the

Aliases: I<drop_left>, I<drop_first>

=cut

=head2 shift_while

    Array.shift_while()

Returns the

=cut

=head2 shuffle

    Array.shuffle()

Returns the

=cut

=head2 slice_after

    Array.slice_after()

Returns the

=cut

=head2 slice_before

    Array.slice_before()

Returns the

=cut

=head2 slices

    array.slices(n)

Slices the self-array into multiple sub-arrays, each sub-array having at most C<n> elements.

    say [1,2,3,4].slices(2)         #=> [[1, 2], [3, 4]]
    say [1,2,3,4,5].slices(2)       #=> [[1, 2], [3, 4], [5]]

Aliases: I<map_slice>

=cut

=head2 smul

    Array.smul()

Returns the

Aliases: I<scalar_mul>

=cut

=head2 solve_seq

    arr.solve_seq(offset=0)

Returns a Polynomial object that generates the terms of the given sequence.

Example:

    say 20.of { .square }.solve_seq         #=> x^2
    say 20.of { .faulhaber(2) }.solve_seq   #=> 1/3*x^3 + 1/2*x^2 + 1/6*x

Example with offset:

    say 20.of { (_+10)**3 }.solve_seq       #=> x^3 + 30*x^2 + 300*x + 1000
    say 20.of { (_+10)**3 }.solve_seq(10)   #=> x^3

=cut

=head2 sort

    Array.sort()

Returns the

=cut

=head2 sort_by

    arr.sort_by { ... }

Sort an array by mapping each value to the given block.

    [4,3,1,2].sort_by { _ }            # same as .sort()
    [4,3,1,2].sort_by {|n| -n }        # reversed numerical sorting
    %w(foo fo f).sort_by { .len }      # sort array by length

=cut

=head2 splice

    Array.splice()

Returns the

=cut

=head2 split

    Array.split()

Returns the

=cut

=head2 split_by

    arr.split_by { ... }

Splits the given array by the objects at which the given block returns a true value.

    say [1,2,0,3,0,4].split_by { _ == 0 }   #=> [[1, 2], [3], [4]]

=cut

=head2 ssub

    Array.ssub()

Returns the

Aliases: I<scalar_sub>

=cut

=head2 stack

    arr.stack
    arr.stack { ... }

Groups runs of identical elements.

    say <a a a b b c>.stack     #=> [["a", "a", "a"], ["b", "b"], ["c"]

When a block of code is given, the stocking is done based on the mapping of each element to the given block:

    say <A B b A b B A>.stack_by { .uc }

Output:

    [["A"], ["B", "b"], ["A"], ["b", "B"], ["A"]]

Aliases: I<stack_by>

=cut

=head2 subsets

    Array.subsets()

Returns the

=cut

=head2 sum

    Array.sum()

Returns the

=cut

=head2 sum_2d

    arr.sum_2d {|a,b,c,...| ... }

Sum of a 2D array, by mapping each row to the given block.

    say [[2,4],[3,2],[5,1],[7,1]].sum_2d {|p,k| p**k }     #=> 37

=cut

=head2 sum_by

    arr.sum_by { ... }

Sum of an array, by mapping each element to the given block.

    say [1,2,3,4].sum_by {|n| n**2 }    # sum of each element squared

=cut

=head2 sum_kv

    Array.sum_kv()

Returns the

=cut

=head2 swap

    Array.swap()

Returns the

=cut

=head2 take_left

    Array.take_left()

Returns the

=cut

=head2 take_right

    Array.take_right()

Returns the

=cut

=head2 to_a

    Array.to_a()

Returns the

Aliases: I<to_array>

=cut

=head2 to_bag

    Array.to_bag()

Returns the

=cut

=head2 to_h

    Array.to_h()

Returns the

Aliases: I<to_hash>

=cut

=head2 to_m

    Array.to_m()

Returns the

Aliases: I<to_matrix>

=cut

=head2 to_s

    Array.to_s()

Returns the

Aliases: I<dump>, I<to_str>

=cut

=head2 to_set

    Array.to_set()

Returns the

=cut

=head2 to_v

    Array.to_v()

Returns the

Aliases: I<to_vector>

=cut

=head2 tuples

    Array.tuples()

Returns the

Aliases: I<variations>

=cut

=head2 tuples_with_repetition

    Array.tuples_with_repetition()

Returns the

Aliases: I<variations_with_repetition>

=cut

=head2 uniq

    Array.uniq()

Returns the

Aliases: I<unique>, I<distinct>

=cut

=head2 uniq_by

    Array.uniq_by()

Returns the

Aliases: I<unique_by>

=cut

=head2 uniq_permutations

    arr.uniq_permutations
    arr.uniq_permutations { ... }

It uses the C<next_permutation> method to create all the unique permutations of the self-array.

    say [1,1,2].unique_permutations         #=> [[1, 1, 2], [1, 2, 1], [2, 1, 1]

Equivalent with C<arr.permutations.uniq>, but more efficient, as it creates the permutations without duplicates.

The method also accepts a callback block as an optional argument:

    [1,1,2].unique_permutations {|*perm|
        say perm
    }

Output:

    [1, 1, 2]
    [1, 2, 1]
    [2, 1, 1]

Aliases: I<unique_permutations>

=cut

=head2 uniq_prefs

    Array.uniq_prefs()

Returns the

Aliases: I<unique_prefixes>

=cut

=head2 unroll_op

    Array.unroll_op()

Returns the

Aliases: I<unroll_operator>

=cut

=head2 unzip_by

    Array.unzip_by()

Returns the

=cut

=head2 weighted_shuffle_by

    Array.weighted_shuffle_by()

Returns the

=cut

=head2 wise_op

    Array.wise_op()

Returns the

Aliases: I<wise_operator>

=cut

=head2 zip

    Array.zip()

Returns the

Aliases: I<transpose>

=cut

=head2 zip_by

    Array.zip_by()

Returns the

=cut

=head2 zip_op

    Array.zip_op()

Returns the

Aliases: I<zip_operator>

=cut
