
=encoding utf8

=head1 NAME

Sidef::Types::Array::Array

=head1 DESCRIPTION

This module provides the support for arrays.

=head1 SYNOPSIS

=over 2

=item * Creating an array

    var array = (Array.new(obj1, obj2, ...));

or

    var array = [obj1, obj2, ...];

or

    var array = qw(word1 word2 ...);

=item * Retrieving an element

    var elem = array[index];

=item * Modifying an element

    array[index] = someObj;

=item * Applying methods on arrays

    array->method(argument1, argument2, ...);

=back

=head1 INHERITS

Inherits methods from:

    * Sidef
    * Sidef::Convert::Convert

=head1 METHODS

=head2 !=

I<Obj> B<!=> I<Obj> -> I<Obj>

Return the

Aliases: I<ne>

=cut

=head2 and

Alias for L<C<&>|"&">.

=cut

=head2 *

I<Obj> B<*> I<Obj> -> I<Obj>

Return the

Aliases: I<multiply>

=cut

=head2 +

I<Array> B<+> I<Array> -> I<Array>

Concatenate two arrays.

    [1, 2] + [3, 4];   # returns [1, 2, 3, 4]

Aliases: I<concat()>.

Returns a new object of the same type as the self object.

=cut

=head2 ++

=over 2

=item * I<Array> B<++> I<Obj> -> I<Array>

Append one element to array.

    array ++ "str";      # "str" has been pushed into array

=back

=over 2

=item * I<Array>B<++> -> I<Array>

Increases the array's size by one element.

    array++;             # array size is increased by one

=back

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 +=

I<Obj> B<+=> I<Obj> -> I<Obj>

Return the

=cut

=head2 -

I<Obj> B<-> I<Obj> -> I<Obj>

Return the

Aliases: I<subtract>

=cut

=head2 --

I<Array>B<--> -> I<Array>

Remove the last element from the array.

    [1, 2, 3]--;        # returns [1, 2]

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 ...

I<Obj> B<...> I<Obj> -> I<Obj>

Return the

Aliases: I<to_list>

=cut

=head2 /

I<Obj> B</> I<Obj> -> I<Obj>

Return the

Aliases: I<div>, I<divide>

=cut

=head2 :

I<Obj> B<:> I<Obj> -> I<Obj>

Return the

Aliases: I<pair_with>, I<pairWith>

=cut

=head2 <<

I<Obj> B<E<lt>E<lt>> I<Obj> -> I<Obj>

Return the

Aliases: I<shift>, I<drop_left>, I<dropLeft>, I<drop_first>, I<dropFirst>

=cut

=head2 =

I<Slice> B<=> I<Array> -> I<Slice>

This method is used to change the elements in a slice of array.

    array = ["a", "b", "c"];
    array[1, 3, 5]  = ["x", "y", "z"];       # changes the slice elements with the elements from the argument array

    # array is now: ['a', 'x', 'c', 'y', nil, 'z']

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 ==

I<Obj> B<==> I<Obj> -> I<Obj>

Return the

Aliases: I<eq>, I<is>, I<equals>

=cut

=head2 pop

=over 2

=item * Array.pop(I<Number>) -> I<Obj>

Remove the element from the specified position.

    array = qw(a b c);
    array.pop(1);       # returns the removed element from position 1: 'b'

    # array contains: ['a', 'c']

=back

=over 2

=item * Array.pop() -> I<Obj>

Removes the last element of the array.

    array = qw(a b c);
    array.pop;          # returns the removed last element: 'c'

    # array contains: ['a', 'b']

=back

B<WARNING!> This method modifies the array in place.

=cut

=head2 ^

I<Obj> B<^> I<Obj> -> I<Obj>

Return the

Aliases: I<xor>

=cut

=head2 abbrev

Array.abbrev() -> I<Obj>

Return the

Aliases: I<abbreviations>

=cut

=head2 all

Array.all(I<Block>) -> I<Bool>

Returns true if all the array's elements passes the block test.

    ["a", "b", "c"].all { _ < "d"  };       # true
    [0, 2, 4, 6, 8].all { _ % 2 == 0 };     # true
    [101, 102, 103].all { _ > 102 };        # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 any

Array.any() -> I<Obj>

Return the

=cut

=head2 bshuffle

Array.bshuffle() -> I<Obj>

Return the

Aliases: I<best_shuffle>, I<bestShuffle>

=cut

=head2 combination

Array.combination() -> I<Obj>

Return the

Aliases: I<combinations>

=cut

=head2 contains

Array.contains(I<Obj>) -> I<Bool>

Returns true if the array contains the argument object.

    ['x','y','z'].contains('y');        # true
    [1,[2,3],4,5].contains([2,3]);      # true
    [1,2,[3],4,5].contains(3);          # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 contains_all

Array.contains_all() -> I<Obj>

Return the

Aliases: I<containsAll>

=cut

=head2 contains_any

Array.contains_any() -> I<Obj>

Return the

Aliases: I<containsAny>

=cut

=head2 contains_type

Array.contains_type() -> I<Obj>

Return the

Aliases: I<containsType>

=cut

=head2 copy

Array.copy() -> I<Array>

Returns a copy of the self array.

=cut

=head2 count

Array.count(I<Obj>) -> I<Number>

Count the number of objects indentical with the argument.

    ["x", "y", "y", "z"].count("y");    # returns: 2

Aliases: I<count_obj()>, I<countObj()>.

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 defined

Array.defined(I<Number>) -> I<Bool>

Returns true if the element from the I<Number> position is defined.

    [1,2,3,4,5,6].defined(0);     # true
    ['a','b',nil].defined(2);     # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 delete

Array.delete() -> I<Obj>

Return the

Aliases: I<remove>

=cut

=head2 delete_first

Array.delete_first() -> I<Obj>

Return the

Aliases: I<deleteFirst>, I<remove_first>, I<removeFirst>

=cut

=head2 delete_first_if

Array.delete_first_if() -> I<Obj>

Return the

Aliases: I<deleteFirstIf>, I<remove_first_if>, I<removeFirstIf>

=cut

=head2 delete_if

Array.delete_if() -> I<Obj>

Return the

Aliases: I<deleteIf>, I<remove_if>, I<removeIf>

=cut

=head2 dump

Array.dump() -> I<String>

Returns a string representation of the array.

    qw(a b c).dump;     # returns: "['a', 'b', 'c']"

Returns an object of type: C<Sidef::Types::String::String>

=cut

=head2 each_index

Array.each_index() -> I<Obj>

Return the

=cut

=head2 each_with_index

Array.each_with_index() -> I<Obj>

Return the

=cut

=head2 offset

Array.offset() -> I<Number>

Returns the last index of the array.

    ['a','b','c'].offset;       # returns: 2

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 exists

Array.exists() -> I<Obj>

Return the

Aliases: I<existsIndex>

=cut

=head2 find

Array.find(I<Block>) -> I<Obj>

Find an element inside the array.

    [1, 2, 1, 7, 5, 8].find { _ >= 4 };           # returns: 7
    ['Hello', 'World'].find { _ =~ /^w/i ?? };    # returns: 'World'

Returns the first element found.

=cut

=head2 first

Array.first() -> I<Obj>

Returns the first element of the array.

=cut

=head2 firstIndex

Array.firstIndex(I<Block>) -> I<Number>

Returns the index of the first element which passes the block test. Works just like the L<C<find()>|"find"> method, except that it returns the possition of the element, not the element itself.

    ['a','b','c'].firstIndex { _ == 'c' };      # returns: 3
    [1,2,3,4,5,6].firstIndex { _ >= 100 };      # returns: -1

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 flatten

Array.flatten() -> I<Obj>

Return the

=cut

=head2 for

Array.for() -> I<Obj>

Return the

Aliases: I<each>, I<foreach>

=cut

=head2 ft

Array.ft() -> I<Obj>

Return the

Aliases: I<from_to>, I<fromTo>

=cut

=head2 get

Array.get() -> I<Obj>

Return the

Aliases: I<item>

=cut

=head2 filter

Array.filter(I<Block>) -> I<Array>

Filter the array's elements via a block test.

    ['a','b','c'].filter { _ > 'a'};   # returns: ['b', 'c']
    [1,2,3,4,5,6].filter { _ <= 3};    # returns: [1, 2, 3]

Returns a new object of the same type as the self object.

=cut

=head2 group_by

Array.group_by() -> I<Obj>

Return the

Aliases: I<groupBy>

=cut

=head2 reduce

=over 2

=item * Array.reduce(I<Block>) -> I<Bool>

Reduces array by calling I<Block>, multiple times, setting C<_[0]> and C<_[1]> each time. The first call will be with C<_[0]> and C<_[1]> set to the first two elements of the list, subsequent calls will be done by setting C<_[0]> to the result of the previous call and C<_[1]> to the next element in the list.

    [1,2,3,4].reduce { _[0] + _[1] };   # returns the sum of array's elements (1+2+3+4 = 10)

=back

=over 2

=item * Array.reduce(I<String>) -> I<Bool>

Almost the same as when it takes a block argument, but much more limited.

    [1,2,3,4].reduce('*');      # returns the product of array's elements (1*2*3*4 = 24)

=back

Returns an object of the same type as the elements of the array.

=cut

=head2 insert

Array.insert(I<Number>, I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Insert elements inside the array at a given position.

    array = qw(a b f);
    array.insert(2, 'c', 'd', 'e');     # returns: ['a', 'b', 'c', 'd', 'e', 'f']

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 is_empty

Array.is_empty() -> I<Obj>

Return the

Aliases: I<isEmpty>

=cut

=head2 join

Array.join(I<String>) -> I<String>

Join the array as a string.

    qw(apples pears apricots).join(", ");      # returns: "apples, pears, apricots"

Returns an object of type: C<Sidef::Types::String::String>

=cut

=head2 joinInsert

Array.joinInsert(I<Object>) -> I<Array>

Insert after each element the argument object. The array is B<NOT> modified in place.

    ['a','b','c'].joinInsert('--');     # returns: ['a','--','b','--','c']

Returns a new object of the same type as the self object.

=cut

=head2 last

Array.last() -> I<Obj>

Returns the last element of the array.

=cut

=head2 lastIndex

Array.lastIndex(I<Block>) -> I<Number>

Works just like L<C<firstIndex()>|"firstIndex">, except that it searches backwards and returns the index of the last element of the array which passed the block test.

    [1,2,3,4,5,6].firstIndex { _**2 < 20 };     # returns: 3

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 last_uniq

Array.last_uniq() -> I<Obj>

Return the

Aliases: I<lastUniq>, I<last_unique>, I<lastUnique>

=cut

=head2 len

Array.len() -> I<Obj>

Return the

Aliases: I<size>, I<length>

=cut

=head2 lev

Array.lev() -> I<Obj>

Return the

Aliases: I<leven>, I<levenshtein>

=cut

=head2 make

Array.make(I<Number>, I<Obj>) -> I<Array>

Make a new array of I<Number> size, contaiting the I<Obj> on every position.

    Array.make(3, Num);     # returns: [0,0,0]
    Array.make(3, "x");     # returns: ['x','x','x']

Returns a new object of the same type as the self object.

=cut

=head2 map

Array.map() -> I<Obj>

Return the

Aliases: I<collect>

=cut

=head2 map_operator

Array.map_operator() -> I<Obj>

Return the

=cut

=head2 max

Array.max() -> I<Obj>

Returns the greatest element of the list. Each element must have the C<E<gt>> method associated.

    [5,7,8,2,3,1].max;        # returns: 8
    ['l','w','p'].max;        # returns: 'w'

Returns an object of the same type as the elements of the array.

=cut

=head2 max_by

Array.max_by() -> I<Obj>

Return the

Aliases: I<maxBy>

=cut

=head2 min

Array.min() -> I<Obj>

Works just like the L<C<max()>|"max"> method, except that it returns the lower element, instead of the greatest one.

    [4,2,3,5,7,8].min;       # returns: 2
    ['s','p','d'].min;       # returns: 'd'

Returns an object of the same type as the elements of the array.

=cut

=head2 min_by

Array.min_by() -> I<Obj>

Return the

Aliases: I<minBy>

=cut

=head2 minmax

Array.minmax() -> I<Obj>

Return the

=cut

=head2 new

Array.new(I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Creates a new array.

    Array.new(1,2,3);       # returns: [1, 2, 3]

Returns a new object of the same type as the self object.

=cut

=head2 pack

Array.pack() -> I<Obj>

Return the

=cut

=head2 pairs

Array.pairs() -> I<Obj>

Return the

=cut

=head2 pam_operator

Array.pam_operator() -> I<Obj>

Return the

=cut

=head2 permute

Array.permute() -> I<Obj>

Return the

Aliases: I<permutations>

=cut

=head2 pick

Array.pick() -> I<Obj>

Return the

Aliases: I<rand>, I<sample>

=cut

=head2 pop_at

Array.pop_at() -> I<Obj>

Return the

Aliases: I<popAt>, I<delete_index>, I<deleteIndex>

=cut

=head2 pop_rand

Array.pop_rand() -> I<Obj>

Return the

Aliases: I<popRand>

=cut

=head2 prepend

Array.prepend() -> I<Obj>

Return the

Aliases: I<unshift>

=cut

=head2 product

Array.product() -> I<Obj>

Works just like the L<C<sum()>|"sum"> method, except that it multiplies each element of the array, using the C<*> method.

    [5,6,7].product;       # returns the product number (210)

Returns an object of the same type as the elements of the array.

=cut

=head2 range

Array.range() -> I<Array>

Returns a new array with numbers ranging from C<0> to C<array.offset>.

    ['x','y','z'].range;       # returns: [0, 1 ,2]

This method always returns an object of type: C<Sidef::Types::Array::Array>

=cut

=head2 reduce_operator

Array.reduce_operator() -> I<Obj>

Return the

=cut

=head2 reduce_pairs

Array.reduce_pairs() -> I<Obj>

Return the

Aliases: I<reducePairs>

=cut

=head2 resize

Array.resize() -> I<Obj>

Return the

Aliases: I<resize_to>, I<resizeTo>

=cut

=head2 reverse

Array.reverse() -> I<Obj>

Return the

Aliases: I<reversed>

=cut

=head2 rotate

Array.rotate() -> I<Obj>

Return the

=cut

=head2 shuffle

Array.shuffle() -> I<Obj>

Return the

=cut

=head2 slice

Array.slice() -> I<Obj>

Return the

=cut

=head2 sort

Array.sort() -> I<Obj>

Return the

=cut

=head2 splice

Array.splice() -> I<Obj>

Return the

=cut

=head2 sum

Array.sum() -> I<Obj>

Reduces all the elements from the array to a single element, using the C<+> method.

    [[1,2],[3,4]].sum;       # returns: [1,2,3,4]
    [1,2,3,4,5,6].sum;       # returns the sum of the numbers (1+2+3+...+6)

Returns an object of the same type as the elements of the array.

Aliases: I<collapse>

=cut

=head2 swap

Array.swap() -> I<Obj>

Return the

=cut

=head2 take_left

Array.take_left() -> I<Obj>

Return the

Aliases: I<takeLeft>

=cut

=head2 take_right

Array.take_right() -> I<Obj>

Return the

Aliases: I<takeRight>

=cut

=head2 to_h

Array.to_h() -> I<Obj>

Return the

Aliases: I<to_hash>, I<toHash>

=cut

=head2 to_s

Array.to_s() -> I<Obj>

Return the

=cut

=head2 uniq

Array.uniq() -> I<Obj>

Return the

Aliases: I<unique>, I<distinct>

=cut

=head2 unroll_operator

Array.unroll_operator() -> I<Obj>

Return the

=cut

=head2 mesh

Alias for L<C<&&>|"&&">.

=cut

=head2 |

I<Obj> B<|> I<Obj> -> I<Obj>

Return the

Aliases: I<or>

=cut

=head2 push

Array.push(I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Append some elements to array.

    array = qw(s i d);
    array.push("e", "f");      # pushes the element to array and returns: qw(s i d e f)

Aliases: I<append()>.

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 »

I<Obj> B<»> I<Obj> -> I<Obj>

Return the

Aliases: I<assign_to>, I<assignTo>, I<unroll_to>, I<unrollTo>

=cut
