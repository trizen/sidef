
=encoding utf8

=head1 NAME

Sidef::Types::Array::Array

=head1 DESCRIPTION

This module provides the support for arrays.

=head1 SYNOPSIS

=over 2

=item * Creating an array

    var array = (Array.new(obj1, obj2, ...));

or

    var array = [obj1, obj2, ...];

or

    var array = qw(word1 word2 ...);

=item * Retrieving elements

    var elem = array[index];

=item * Modifying elements

    array[index] = someObj;

=item * Applying methods on arrays

    array->method(argument1, argument2, ...);

=back

=head1 INHERITS

Inherits methods from:

    * Sidef
    * Sidef::Convert::Convert

=head1 METHODS


=head2 &

I<Array> B<&> I<Array> -> I<Array>

Returns a new array with the elements which exists in both arrays.

    [1, 2, 3] & [1, 3];        # returns [1, 3]
    [1, 3, 3] & [3, 3, 5];     # returns [3, 3]

Returns a new object of the same type as the self object.

=cut

=head2 &&

I<Array> B<&&> I<Array> -> I<Array>

Intersect two arrays. The self array is the primary array.

    ['a', 'c'] && ['b', 'd'];     # returns ['a', 'b', 'c', 'd']

Returns a new object of the same type as the self object.

=cut

=head2 +

I<Array> B<+> I<Array> -> I<Array>

Concatenate two arrays.

    [1, 2] + [3, 4];   # returns [1, 2, 3, 4]

Returns a new object of the same type as the self object.

=cut

=head2 ++

=over 2

=item * I<Array> B<++> I<Obj> -> I<Array>

Append one element to array.

    array ++ "str";      # "str" has been pushed into array

=back

=over 2

=item * I<Array>B<++> -> I<Array>

Increases the array's size by one element.

    array++;             # array size is increased by one

=back

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 -

I<Array> B<-> I<Array> -> I<Array>

Return the difference between two arrays. This is the opposite of the L<C<&>|"&"> method.

    ["x", "y", "z"] - ["y", "x"]    # returns ["z"]

Returns a new object of the same type as the self object.

=cut

=head2 --

I<Array>B<--> -> I<Array>

Remove the last element from the array.

    [1, 2, 3]--;        # returns [1, 2]

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 ...

I<Array>B<...> -> I<List>

Return the elements of the array as a list. Useful only when an array is passed to a function as a list of arguments.

    array = ['x', 'y'];
    some_func(array...);        # the function receives two arguments: ("x", "y")

Returns a list with the elements from the self array. In scalar context, only the first element is returned.

=cut

=head2 <<

I<Array> B<E<lt>E<lt>> I<Number> -> I<Array>

Shift the array to the left with I<Number> elements, and return the elements removed. The I<Number> must be positive.

    array = [1, 2, 3, 4, 5];
    array << 2;                 # returns the first two elements: [1,2]

    # The array lost its first two elements, so it contains only: [3, 4, 5]

B<WARNING!> This method modifies the array in place.

Returns a new object of the same type as the self object.

=cut

=head2 =

I<Slice> B<=> I<Array> -> I<Slice>

This method is used to change the elements in a slice of array.

    array = ["a", "b", "c"];
    array[1, 3, 5]  = ["x", "y", "z"];       # changes the slice elements with the elements from the argument array

    # array is now: ['a', 'x', 'c', 'y', nil, 'z']

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 ==

I<Array> B<==> I<Array> -> I<Bool>

Check to see if two arrays contains the same elements. The arrays are checked recursively.

    [1,[2,3],4]  == [1,[2,3],4];   # true
    [1,[8,9],4]  == [1,[2,3],4];   # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 >>

I<Array> B<E<gt>E<gt>> I<Number> -> I<Array>

Shift the array to the right with I<Number> elements, and return the elements removed. The I<Number> must be positive.

    array = [1, 2, 3, 4, 5];
    array >> 2;                 # returns the last two elements: [4, 5]

    # The array lost its last two elements, so it contains only: [1,2,3]

B<WARNING!> This method modifies the array in place.

Returns a new object of the same type as the self object.

=cut

=head2 ^

I<Array> B<^> I<Array> -> I<Array>

Returns a new array with the elements which doesn't exists in both arrays.

    [2,3] ^ [3,1];          # returns: [2,1]
    [1,2] ^ [1,2,3,4];      # returns: [3,4]

Returns a new object of the same type as the self object.

=cut

=head2 all

Array.all(I<Block>) -> I<Bool>

Returns true if all the array's elements passes the block test.

    ["a", "b", "c"].all { _ < "d"  };       # true
    [0, 2, 4, 6, 8].all { _ % 2 == 0 };     # true
    [101, 102, 103].all { _ > 102 };        # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 combine

Array.combine() -> I<Obj>

Combine all the elements from the array togheter. The array's elements must have a C<+> method associated.

    [[1,2],[3,4]].combine;       # returns: [1,2,3,4]
    [1,2,3,4,5,6].combine;       # returns the sum of the numbers (21)

Returns an object of the same type as the elements of the array.

=cut

=head2 contains

Array.contains(I<Obj>) -> I<Bool>

Returns true if the array contains the argument object.

    ['x','y','z'].contains('y');        # true
    [1,[2,3],4,5].contains([2,3]);      # true
    [1,2,[3],4,5].contains(3);          # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 defined

Array.defined(I<Number>) -> I<Bool>

Returns true if the element from the I<Number> position is defined.

    [1,2,3,4,5,6].defined(0);     # true
    ['a','b',nil].defined(2);     # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 distinct

Array.distinct() -> I<Array>

Returns only the unique objects from the array.

    [1,2,2,[3],4,[3],4].distinct;   # returns: [1,2,[3],4]

Returns an object of the same type as the self object.

=cut

=head2 dropLeft

Alias for L<C<E<lt>E<lt>>|"E<lt>E<lt>">.

=cut

=head2 dropRight

Alias for L<C<E<gt>E<gt>>|"E<gt>E<gt>">.

=cut

=head2 dump

Array.dump() -> I<String>

Returns a string representation of the array.

    qw(a b c).dump;     # returns: "['a', 'b', 'c']"

Returns an object of type: C<Sidef::Types::String::String>

=cut

=head2 exists

Array.exists(I<Number>) -> I<Bool>

Returns true if the array has an element on the specified index.

    ['a','b','c'].exists(1);    # true
    ['a','b','c'].exists(5);    # false

Returns an object of type: C<Sidef::Types::Bool::Bool>

=cut

=head2 filter

Array.filter(I<Block>) -> I<Array>

Filter the array's elements via a block test.

    ['a','b','c'].filter { _ > 'a'};   # returns: ['b', 'c']
    [1,2,3,4,5,6].filter { _ <= 3};    # returns: [1, 2, 3]

Returns a new object of the same type as the self object.

=cut

=head2 find

Array.find(I<Block>) -> I<Obj>

Find an element inside the array.

    [1, 2, 1, 7, 5, 8].find { _ >= 4 };           # returns: 7
    ['Hello', 'World'].find { _ =~ /^w/i ?? };    # returns: 'World'

Returns the first element found.

=cut

=head2 first

Array.first() -> I<Obj>

Returns the first element of the array.

=cut

=head2 firstIndex

Array.firstIndex(I<Block>) -> I<Number>

Returns the index of the first element which passes the block test. Works just like the L<C<find()>|"find"> method, except that it returns the possition of the element, not the element itself.

    ['a','b','c'].firstIndex { _ == 'c' };      # returns: 3
    [1,2,3,4,5,6].firstIndex { _ >= 100 };      # returns: -1

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 first_index

Alias for L<C<firstIndex()>|"firstIndex">.

=cut

=head2 fromTo

Array.fromTo() -> I<Bool>

Return the

=cut

=head2 ft

Array.ft(I<Number>, I<Number>) -> I<Array>

Returns the element from the array from within a specified range.

    array.(from, to);

If the second argument is omitted, will go till the end of the array.

    ['w', 'x', 'y', 'z'].ft(2);         # returns ['y', 'z']
    ['m', 'n', 'o', 'p'].ft(1, 2);      # returns ['n', 'o']

Returns an object of the same type as the self object.

=cut

=head2 grep

Alias for L<C<filter()>|"filter">.

=cut

=head2 indexWhere

Alias for L<C<firstIndex()>|"firstIndex">.

=cut

=head2 insert

Array.insert(I<Number>, I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Insert elements inside the array at a given position.

    array = qw(a b f);
    array.insert(2, 'c', 'd', 'e');     # returns: ['a', 'b', 'c', 'd', 'e', 'f']

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 join

Array.join(I<String>) -> I<String>

Join the array as a string.

    qw(apples pears apricots).join(", ");      # returns: "apples, pears, apricots"

Returns an object of type: C<Sidef::Types::String::String>

=cut

=head2 joinInsert

Array.joinInsert(I<Object>) -> I<Array>

Insert after each element the argument object. The array is B<NOT> modified in place.

    ['a','b','c'].joinInsert('--');     # returns: ['a','--','b','--','c']

Returns a new object of the same type as the self object.

=cut

=head2 join_insert

Alias for L<C<joinInsert()>|"joinInsert">.

=cut

=head2 last

Array.last() -> I<Obj>

Returns the last element of the array.

=cut

=head2 lastIndex

Array.lastIndex(I<Block>) -> I<Number>

Works just like L<C<firstIndex()>|"firstIndex">, except that it searches backwards and returns the index of the last element of the array which passed the block test.

    [1,2,3,4,5,6].firstIndex { _**2 < 20 };     # returns: 3

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 lastIndexWhere

Alias for L<C<lastIndex()>|"lastIndex">.

=cut

=head2 last_index

Alias for L<C<lastIndex()>|"lastIndex">.

=cut

=head2 len

Array.len() -> I<Number>

Return the length of the array.

    ['a','b','c'].len;      # returns: 3

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 length

Alias for L<C<len()>|"len">.

=cut

=head2 make

Array.make(I<Number>, I<Obj>) -> I<Array>

Make a new array of I<Number> size, contaiting the I<Obj> on every position.

    Array.make(3, Num);     # returns: [0,0,0]
    Array.make(3, "x");     # returns: ['x','x','x']

Returns a new object of the same type as the self object.

=cut

=head2 map

Array.map(I<Block>) -> I<Bool>

Evaluates the I<Block> for each element of I<Array> and returns a new array composed of the results of each such evaluation.

    [1,2,3].map { _ + 10 };     # returns: [11, 12, 13]

B<WARNING!> By modifing the C<_> variable, the modification is visible inside the self array.

Returns a new object of the same type as the self object.

=cut

=head2 max

Array.max() -> I<Obj>

Returns the greatest element of the list. Each element must have the C<E<gt>> method associated.

    [5,7,8,2,3,1].max;        # returns: 8
    ['l','w','p'].max;        # returns: 'w'

Returns an object of the same type as the elements of the array.

=cut

=head2 mesh

Alias for L<C<&&>|"&&">.

=cut

=head2 min

Array.min() -> I<Obj>

Works just like the L<C<max()>|"max"> method, except that it returns the lower element, instead of the greatest one.

    [4,2,3,5,7,8].min;       # returns: 2
    ['s','p','d'].min;       # returns: 'd'

Returns an object of the same type as the elements of the array.

=cut

=head2 multiply

Array.multiply() -> I<Obj>

Works just like the L<C<combine()>|"combine"> method, except that it multiplies each element of the array, using the C<*> method. Useful for working with matrices.

    [5,6,7].multiply;       # returns the product number (210)

Returns an object of the same type as the elements of the array.

=cut

=head2 new

Array.new(I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Creates a new array.

    Array.new(1,2,3);       # returns: [1, 2, 3]

Returns a new object of the same type as the self object.

=cut

=head2 offset

Array.offset() -> I<Number>

Returns the last index of the array.

    ['a','b','c'].offset;       # returns: 2

Returns an object of type: C<Sidef::Types::Number::Number>

=cut

=head2 pop

=over 2

=item * Array.pop(I<Number>) -> I<Obj>

Remove the element from the specified position.

    array = qw(a b c);
    array.pop(1);       # returns the removed element from position 1: 'b'

    # array contains: ['a', 'c']

=back

=over 2

=item * Array.pop() -> I<Obj>

Removes the last element of the array.

    array = qw(a b c);
    array.pop;          # returns the removed last element: 'c'

    # array contains: ['a', 'b']

=back

B<WARNING!> This method modifies the array in place.

=cut

=head2 push

Array.push(I<Obj1>, I<Obj2>, I<...>) -> I<Array>

Append some elements to array.

    array = qw(s i d);
    array.push("e", "f");      # pushes the element to array and returns: qw(s i d e f)

B<WARNING!> This method modifies the array in place.

Returns the self object.

=cut

=head2 range

Array.range() -> I<Array>

Returns a new array with numbers ranging from C<0> to C<array.offset>.

    ['x','y','z'].range;       # returns: [0, 1 ,2]

This method always returns an object of type: C<Sidef::Types::Array::Array>

=cut

=head2 reduce

=over 2

=item * Array.reduce(I<Block>) -> I<Bool>

Reduces array by calling I<Block>, multiple times, setting C<_[0]> and C<_[1]> each time. The first call will be with C<_[0]> and C<_[1]> set to the first two elements of the list, subsequent calls will be done by setting C<_[0]> to the result of the previous call and C<_[1]> to the next element in the list.

    [1,2,3,4].reduce { _[0] + _[1] };   # returns the sum of array's elements (1+2+3+4 = 10)

=back

=over 2

=item * Array.reduce(I<String>) -> I<Bool>

Almost the same as when it takes a block argument, but much more limited.

    [1,2,3,4].reduce('*');      # returns the product of array's elements (1*2*3*4 = 24)

=back

Returns an object of the same type as the elements of the array.

=cut

=head2 reducePairs

Array.reducePairs() -> I<Bool>

Return the

=cut

=head2 reverse

Array.reverse() -> I<Bool>

Return the

=cut

=head2 reversed

Array.reversed() -> I<Bool>

Return the

=cut

=head2 shift

Array.shift() -> I<Bool>

Return the

=cut

=head2 shuffle

Array.shuffle() -> I<Bool>

Return the

=cut

=head2 size

Array.size() -> I<Bool>

Return the

=cut

=head2 sliceReverse

Array.sliceReverse() -> I<Bool>

Return the

=cut

=head2 sort

Array.sort() -> I<Bool>

Return the

=cut

=head2 splice

Array.splice() -> I<Bool>

Return the

=cut

=head2 sum

Array.sum() -> I<Bool>

Return the

=cut

=head2 takeLeft

Array.takeLeft() -> I<Bool>

Return the

=cut

=head2 takeRight

Array.takeRight() -> I<Bool>

Return the

=cut

=head2 toHash

Array.toHash() -> I<Bool>

Return the

=cut

=head2 to_hash

Array.to_hash() -> I<Bool>

Return the

=cut

=head2 uniq

Array.uniq() -> I<Bool>

Return the

=cut

=head2 uniqLast

Array.uniqLast() -> I<Bool>

Return the

=cut

=head2 uniq_last

Array.uniq_last() -> I<Bool>

Return the

=cut

=head2 unique

Array.unique() -> I<Bool>

Return the

=cut

=head2 uniqueLast

Array.uniqueLast() -> I<Bool>

Return the

=cut

=head2 unique_last

Array.unique_last() -> I<Bool>

Return the

=cut

=head2 unshift

Array.unshift() -> I<Bool>

Return the

=cut

=head2 zip

Array.zip() -> I<Bool>

Return the

=cut

=head2 |

I<Num> B<|> I<Num> -> I<Num>

Return the

=cut
