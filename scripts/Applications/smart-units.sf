#!/usr/bin/ruby

#`(if running under some shell) {
    eval 'exec /usr/bin/sidef $0 ${1+"$@"}'
}

# Author: Daniel "Trizen" È˜uteu
# License: GPLv3
# Date: 17 May 2014
# Latest edit on: 12 December 2015
# Website: https://github.com/trizen/smart-units

#
## Requires Sidef: https://github.com/trizen/sidef
#

define VERSION = 0.05;

func more_help {
    print <<"HELP";
Mass:
    42 kg to lbs        : convert kilograms to pounds
    30 t to grams       : convert tonnes to grams
    10 lbs to quintals  : convert pounds to quintals

Temperature:
    120 F to C          : convert fahrenheit to celsius
    -15 C to K          : convert celsius to kelvin
    420 K to F          : convert kelvin to fahrenheit

Length:
    21.1 in to cm       : convert inches to centimetres
    5.6 feet to m       : convert feet to meters
    4 light years to km : convert light years to km

Velocity:
    4444 mph to km/s        : convert miles per hour to km/s
    50 m/s to km/h          : convert meters per second to km/h
    speed of sound in mi/s  : convert the speed of sound in mi/s

Time:
    2 hours in sec      : convert hours to seconds
    3 years in mons     : convert years to mons
    4 days in hours     : convert days to hours

Information:
    one byte to bits    : convert bytes to bits
    32MB in KB          : convert megabytes in kilobytes
    3 TB in GB          : convert terabytes in gigabytes

...and more that are left for you to discover!
HELP
}

class Units(precision = 2) {
    static conversions = :(
        mass => :(  # all relative to 1 kilogram
            grams     => :(re => /^(grams?|gr)$/in,         factor => 1e-3),
            quintals  => :(re => /^(quintals?)$/in,         factor => 1e2),
            tonnes    => :(re => /^(tonn?es?|(?-i:t))$/in,  factor => 1e3),
            kilograms => :(re => /^(kg|kilograms?)$/in,     factor => 1),
            pounds    => :(re => /^(pounds?|lbs)$/in,       factor => 0.45359237),
        ),
        temperature => :(   # using Celsius as the standard
            celsius    => :(re => /^(celsius|(?-i:C))$/in,    code => {|n, _| n} ),
            kelvin     => :(re => /^(kelvin|(?-i:K))$/in,     code => {|n, to| to ? (n + 273.15) : (-273.15 + n)} ),
            fahrenheit => :(re => /^(fahrenheit|(?-i:F))$/in, code => {|n, to| to ? (32 + n*9/5) : ((n - 32) * 5/9)} ),
            rankine    => :(re => /^(rankine|(?-i:R))$/in,    code => {|n, to| to ? ((n + 273.15) * 9/5) : (n*5/9 - 273.15)} ),
        ),
        time => :(  # all relative to 1 second
            nanoseconds  => :(re => /^(nanosec(ond)?s?|(?-i:ns))/in,     factor => 1e-9),
            microseconds => :(re => /^(microsec(ond)?s?|(?-i:us))/in,    factor => 1e-6),
            milliseconds => :(re => /^(mill?isec(ond)?s?|(?-i:ms))$/in,  factor => 1e-3),
            seconds      => :(re => /^(sec(ond)?s?|(?-i:s))$/in,         factor => 1),
            minutes      => :(re => /^(min(ute)?s?)$/in,                 factor => 60),
            moments      => :(re => /^(mom(ent)?s?)$/in,                 factor => 90),
            hours        => :(re => /^(hours?)$/in,                      factor => 3600),
            days         => :(re => /^(days?)$/in,                       factor => 86400),
            millidays    => :(re => /^(millidays?|(?-i:md))$/in,         factor => 86.4),
            weeks        => :(re => /^(weeks?)$/in,                      factor => 604800),
            months       => :(re => /^(mon(th)?s?)$/in,                  factor => 2629743.83),
            years        => :(re => /^(years?)$/in,                      factor => 31556952),
        ),
        velocity    => :( # all relative to 1 meter / second
            meters_per_second     => :(re => /^ m(et(er|re)s?)? (\/|\s+per\s+) s(ec(ond)?)? $/inx,                  factor => 1),
            miles_per_hour        => :(re => /^ ( mph | mi(les?)? (\/|\s+per\s+) h(our)? ) $/inx,                   factor => 0.44704),
            miles_per_minute      => :(re => /^ ( mpm | mi(les?)? (\/|\s+per\s+) m(in(ute)?)? )$/inx,               factor => 26.8224),
            miles_per_second      => :(re => /^ ( mps | mi(les?)? (\/|\s+per\s+) s(ec(ond)?)? )$/inx,               factor => 1609.344),
            kilometers_per_hour   => :(re => /^ ( kph | k(ilo)?m(et(er|re)s?)? (\/|\s+per\s+) h(our)? )$/inx,       factor => 1 / 3.6),
            metres_per_hour       => :(re => /^ ( m(et(er|re)s?)? (\/|\s+per\s+) h(our)? ) $/inx,                   factor => 1 / 3600),
            kilometers_per_second => :(re => /^ ( kps | k(ilo)?m(et(er|re)s?)? (\/|\s+per\s+) s(ec(ond)?)? ) $/inx, factor => 1e3),
            speed_of_light        => :(re => /^ ( speed\s+of\s+light|(?-i:c) ) $/inx,                               factor => 299792458),
            speed_of_sound        => :(re => /^ ( speed\s+of\s+sound ) $/inx,                                       factor => 340.29),
        ),
        length      => :(   # all relative to 1 meter
            kilometers       => :(re => /^k(ilo)?m(et(er|re)s?)?$/in,      factor => 1e3),
            meters           => :(re => /^m(et(er|re)s?)?$/in,             factor => 1),
            centimetres      => :(re => /^(centimet(er|re)s?|cm)$/in,      factor => 1e-2),
            millimetres      => :(re => /^(millimet(er|re)s?|mm)$/in,      factor => 1e-3),
            micrometres      => :(re => /^(micromet(er|re)s?|um)$/in,      factor => 1e-6),
            nanometres       => :(re => /^(nanomet(er|re)s?|nm)$/in,       factor => 1e-9),
            picometres       => :(re => /^(picomet(er|re)s?|pm)$/in,       factor => 1e-12),
            femtometres      => :(re => /^(femtomet(er|re)s?|fm)$/in,      factor => 1e-15),
            feet             => :(re => /^(feet|ft|foot)$/in,              factor => 0.304799735),
            inches           => :(re => /^(inch(es)?|in|")$/in,            factor => 0.0254),
            miles            => :(re => /^(miles?|mi)$/in,                 factor => 1609.344),
            yards            => :(re => /^(yards?|yd)$/in,                 factor => 0.9144),
            astronomic_units => :(re => /^(astronomic[-\s]*units?|AU)$/in, factor => 149597870700),
            light_seconds    => :(re => /^(light[-\s]*sec(ond)?s?|ls)$/in, factor => 299792458),
            light_minutes    => :(re => /^(light[-\s]*min(ute)?s?|lm)$/in, factor => 1.798754748e10),
            light_hours      => :(re => /^(light[-\s]*hours?|lh)$/in,      factor => 1.0792528488e12),
            light_days       => :(re => /^(light[-\s]*days?|ld)$/in,       factor => 2.59020683712e13),
            light_years      => :(re => /^(light[-\s]*years?|ly)$/in,      factor => 9.4607304725808e15),
        ),
        information   => :( # all relative to 1 byte
            bits           => :(re => /^(bits?)$/in,            factor => 1 / 8),
            bytes          => :(re => /^(bytes?)$/in,           factor => 1),
            kilobytes      => :(re => /^(kilobytes?|ki?b)$/in,  factor => 1024 ** 1),
            megabytes      => :(re => /^(megabytes?|mi?b)$/in,  factor => 1024 ** 2),
            gigabytes      => :(re => /^(gigabytes?|gi?b)$/in,  factor => 1024 ** 3),
            terabytes      => :(re => /^(terabytes?|ti?b)$/in,  factor => 1024 ** 4),
            petabytes      => :(re => /^(petabytes?|pi?b)$/in,  factor => 1024 ** 5),
            exabytes       => :(re => /^(exabytes?|ei?b)$/in,   factor => 1024 ** 6),
            zettabytes     => :(re => /^(zettabytes?|zi?b)$/in, factor => 1024 ** 7),
            yottabytes     => :(re => /^(yottabytes?|yi?b)$/in, factor => 1024 ** 8),
        ),
    );

    method convert(amount, from, to) {
        conversions.each { |category, value|
            value.each { |from_unit, from_data|
                if (from.match(from_data{:re})) {
                    value.each{ |_, to_data|
                        if (to.match(to_data{:re})) {
                            var new_amount = 0;
                            if (category == :temperature) {
                                var std_from = from_data{:code}(amount, false);
                                new_amount   = to_data{:code}(std_from, true);
                            } else {
                                new_amount = (amount / to_data{:factor} * from_data{:factor});
                            }
                            say (new_amount.is_int ? new_amount : new_amount.roundf(-precision));
                            return true;
                        }
                    }
                    STDERR.say("#{category}: I don't know how to convert #{from_unit.gsub('_', ' ')} to #{to}...");
                    return false;
                }
            }
        }

        STDERR.say("I don't know how to convert #{from} to #{to}... Is even '#{from}' a real unit?");
        return false;
    }
}

var precision = 2;
var interactive = false;

func help {
    print <<"USAGE";
usage: #{File.new(__FILE__).basename} [text]

options:
    -i     : start in interactive mode (default: #{interactive})
    -p int : set floating point precision (default: #{precision})

examples:
    144 F to C
    convert 10kg into pounds
    whats the equivalent of 21 inches in meters
    what is the speed of light in miles per hour
USAGE
    Sys.exit(0);
}

var cmd = [];
while (!ARGV.is_empty) {
    given (var arg = ARGV.shift) {
        when ('-p') {
            precision = Num(ARGV.shift);
        }
        when ('-i') {
            interactive = true;
        }
        when ('-h') {
            help();
        }
        default {
            cmd << arg;
        }
    }
}

if (cmd.is_empty && STDIN.is_on_tty) {
    interactive = true;
}

var units = Units(precision);

func main(command) {
    var match = command.match(/^\s*

        # command or question
        (?:(?:convert|how\s+much\s+is|what(?:\s+is|\W*s)(?:\s+the)?(?:\s+equivalent\s+of)?)\s+)?

        # followed by a number or 'a' word or nothing
        ([-+]?\d+(?:\.\d+)?|(?:an?|one)(?=\s)|)

        # unit from (up to 3 words)
        \s*(\S+(?:\s+\S+){0,2})

        # 'to' token
        \s+(?:in|to|into|as)\s+

        # unit to (up to 3 words)
        (\S+(?:\s+\S+){0,2})
    \s*$/ix);

    if (match) {
        var (amount, from, to) = match.captures...;

        if (amount ~~ ['a','an','one','']) {
            amount = 1;
        } else {
            amount.to_f!;
        }

        return units.convert(amount, from, to);
    }
    else {
        more_help();
    }

    return false;
}

if (interactive) {
    print <<"EOT";
Welcome to smart-units #{VERSION} in interactive mode.
EOT
    loop {
        var line = read(">> ", String) \\ break;

        if (line ~~ ['q', 'exit']) {
            break
        }

        main(line)
    }
}
else {
    Sys.exit((cmd.is_empty ? help() : main(cmd.join(' '))) ? 0 : 1);
}
