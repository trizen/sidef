#!/usr/bin/ruby

#
## http://rosettacode.org/wiki/Problem_of_Apollonius
#

class Circle(x,y,r) {
    method to_s { "Circle(#{x}, #{y}, #{r})" };
    method say  { CORE::say self.to_s };
}
Â 
func solve_apollonius(c, s) {
Â 
    var(c1, c2, c3) = c...;
    var(s1, s2, s3) = s...;
Â 
    var ğ‘£11 = (2*c2.x - 2*c1.x);
    var ğ‘£12 = (2*c2.y - 2*c1.y);
    var ğ‘£13 = (c1.x**2 - c2.x**2 + c1.y**2 - c2.y**2 - c1.r**2 + c2.r**2);
    var ğ‘£14 = (2*s2*c2.r - 2*s1*c1.r);
Â 
    var ğ‘£21 = (2*c3.x - 2*c2.x);
    var ğ‘£22 = (2*c3.y - 2*c2.y);
    var ğ‘£23 = (c2.x**2 - c3.x**2 + c2.y**2 - c3.y**2 - c2.r**2 + c3.r**2);
    var ğ‘£24 = (2*s3*c3.r - 2*s2*c2.r);
Â 
    var ğ‘¤12 = (ğ‘£12 / ğ‘£11);
    var ğ‘¤13 = (ğ‘£13 / ğ‘£11);
    var ğ‘¤14 = (ğ‘£14 / ğ‘£11);
Â 
    var ğ‘¤22 = (ğ‘£22/ğ‘£21 - ğ‘¤12);
    var ğ‘¤23 = (ğ‘£23/ğ‘£21 - ğ‘¤13);
    var ğ‘¤24 = (ğ‘£24/ğ‘£21 - ğ‘¤14);
Â 
    var ğ‘ƒ = (-ğ‘¤23 / ğ‘¤22);
    var ğ‘„ = (ğ‘¤24 / ğ‘¤22);
    var ğ‘€ = (-ğ‘¤12*ğ‘ƒ - ğ‘¤13);
    var ğ‘ = (ğ‘¤14 - ğ‘¤12*ğ‘„);
Â 
    var ğ‘ = (ğ‘**2 + ğ‘„**2 - 1);
    var ğ‘ = (2*ğ‘€*ğ‘ - 2*ğ‘*c1.x + 2*ğ‘ƒ*ğ‘„ - 2*ğ‘„*c1.y + 2*s1*c1.r);
    var ğ‘ = (c1.x**2 + ğ‘€**2 - 2*ğ‘€*c1.x + ğ‘ƒ**2 + c1.y**2 - 2*ğ‘ƒ*c1.y - c1.r**2);
Â 
    var ğ· = (ğ‘**2 - 4*ğ‘*ğ‘);
    var rs = ((-ğ‘ - ğ·.sqrt) / 2*ğ‘);
Â 
    var xs = (ğ‘€ + ğ‘*rs);
    var ys = (ğ‘ƒ + ğ‘„*rs);
Â 
    Circle(xs, ys, rs);
}
Â 
var c = [Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)];
say solve_apollonius(c, %n<1 1 1>);
say solve_apollonius(c, %n<-1 -1 -1>);
