#!/usr/bin/ruby

#
## Extend the language with a block and a class
#
class Catch(do, value) {
    method my_catch(block) {
        do ? block.run : value;
    }
}

func my_try(block) {
    var bool = block.run;
    if (bool) {
        Catch.new(do: false, value: bool);
    }
    else {
        Catch.new(do: true, value: bool);
    }
}

var x = 0;

my_try {
    say "Trying...";
    1 == 2;
}
my_catch {
    say "Catched!";
    x = 42;
};

assert_eq(x, 42);


#
## Extend the language using only classes
#

class my_if {

    def did = false;

    method new(cond, callback) {
        !did && cond && (callback(); did = true);
        self;
    };

    # Alias "my_elsif" to "my_if"
    my_if.alias(:my_elsif, new);

    method my_else(callback) {
        !did && callback();
        self;
    }
}

#
## Test elsif (alias for 'my_if')
#
my_if (false) {
    die "my_if error";
}
my_elsif (true) {
    say "my_elsif correct!";
}
my_else {
    die "my_else error";
};

#
## Test my_else
#
my_if (false) {
    die "my_if error";
}
my_elsif (false) {
    die "my_elsif error";
}
my_else {
    say "my_else correct!";
};


#
## Method with block call
#

class Test {
    method hello(callback) {
        callback();
    }
}

var obj = Test();

var y = 0;
obj.hello {
    y = 42;
};
assert_eq(y, 42);

#
## Class init with block call
#

class BlockTest(block) {
    method brun {
        block();
    }
}

var j = 0;
var bt = BlockTest {
    j++;
};
bt.brun;
assert_eq(j, 1);

#
## Block-call as implicit ".each" method
#

var z = 0;

4 { |i|
    print i;      # prints: 1,2,3,4
    z++;
};

"abc" { |c|
    print c;      # prints each character of the string
    z++;
};

['x', 'y'] { |item|
    print item;    # prints each item of the array
    z++;
};

say "";
assert_eq(z, 4+3+2);
