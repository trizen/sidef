#!/usr/bin/perl

# This script will require Lexer.pm
# and execute the returned data struct.

use 5.014;
use strict;
use warnings;

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (qr/^-/ ~~ \@ARGV) {
    getopts('E:dD:', \%args);
}

# It can be executed as:
#   perl sidef -E '"test"->say'

my $code = exists $args{E} ? $args{E} : <<'CODE';

###################################
# Error testing
###################################
# +->say;      # Invalid object type!
# 3->5;        # Invalid method name!
# var->say;    # Attempt to use an uninitialized variable: <var>
###################################


###################################
# Code testing
###################################


#
## Support for multiple arguments
#

"a"->join("::", "b"->uc, "c")->say;   # will print a::B::c


###################
# SUPPORT FOR FILES
###################

var file = ~sidef~;

var size_kb = (file->size / 1024);

"Size of sidef in bytes: "->print;
size_kb * 1024 -> to_s -> say;

"size of file 'sidef': $size_kb KB\n"->print;

var fh = (file->open_r);
"\n** Reading one line from 'sidef':" -> say;
fh->readline->print;

# OR:

file = ("sidef"->stat_file);

"\nFile name is: "->print;
file->name->say;

"Full path is: "->print;
var abs_path = (file->abs_name)->to_s->say;

"Dir name is:  "->print;
abs_path->dirname->to_s->say;

###############################################
##### NEW WAY TO INITIALIZE THE VARIABLES #####
###############################################
#
# optional parentheses for arguments
#
###############################################

var x = "RaNdOm StRiNg"->lc;   # WRONG!!!
var y = ("RaNdOm StRiNg"->lc); # RIGHT!!!
var z = "\LRaNdOm StRiNg";     # Also, right.

var jash = "another Sidef";
"Just $jash hacker,\n"->say;

"\nescaped variable: \$var\n"->say;

#
## Single-quoted string to double-quoted string
#

var single = 'this is a test -- $y -- \n';
single->say;
(single->to_sd)->say;

# -----------------------------------------------

x->say;     # prints 'RaNdOm StRiNg'
y->say;     # prints 'random string'

var name = "Ioana";       # initialize variable "name"

"Hello, $name! How are you? :)\n"->print;
name->uc->say;

6+4/2->to_s->say;       # WRONG!!! Prints 5
6+(4/2)->to_s->say;     # RIGHT!!! Prints 8

12/3*4->to_s->say;      # Prints 16

###############################################
################# OTHER STUFF #################
###############################################

var creepy = "\\tthis is a creepy string\\n\n";
creepy->print;
creepy->apply_escapes->print;

"Hello, World"->substr(0, 5)->say;
"Hello, World"->substr( -5 )->say;

var num = 42;
"Next power of two after number $num is: "->print;
num->next_power_of_two->to_s->say;

var init = "^_^ Sidef ^_^"->say;  # assings to variable 'init', and prints it
init->uc->say;                    # upper cases the variable 'init', and prints it again

"\n\uvariable interpolation ==> \L$init\\\\\E <== is Working\n"->say;

var hello = "Hello, World!";      # assign a string value to variable 'hello'
hello->say;                       # prints "Hello, World!" from var 'hello'

hello = ("Goodbye, World!\n");    # assign another string to variable 'hello'
hello->print;                     # prints the last assigned string.

var diff = (43-23);               # assign value to 'diff'
diff->to_s->say;                  # print the value stored into 'diff' (20)

(42 / ( 3/(1.0) ) )->to_s->say;   # prints 14

24 -> / (6)->to_s->say;           # prints 4 ( "/" is a method! )

((((((60+(40)))))))->to_s->say;   # prints 100

((42-(4.3*(3)))/(6))->to_s->say;  # prints 4.85

-81->abs->sqrt->to_s->say;        # prints 9

10/(3)->to_s->say;                # prints 3.3333333333333

24/(18*(3/(1)))->to_s->say;       # prints 0.444444444444444

"StRinG"->lc->uc->say;            # prints STRING

44.2->int->log10->to_s->say;      # prints 1.64345267648619

###################################

const pi = 3.14;                  # print constant value
#pi = 11;                         # Testing warning
pi->to_s->say;

["test", 44, 123, ["aa", "bb"], ["x"->uc, 4*3, [32,4+3], "y"->uc]]->pop->to_s->say;

var array = [1,2,3];
var array2 = [1,2];
var left = [array ,array2];
left->pop->to_s->say;

array->pop->to_s->say;  # prints '3'

(["x","y","z"])->pop->say;

#####################################################

#
## Remove from array 1 anything listed in array 2.
#

["w","x"->uc,"y", 3, [5], "IT"] - ["w", [5], "Y"->lc] -> to_s->say;

#
## same thing as above:
#

var arr_1 = ["w","x"->uc,"y", 3, [5], "IT"];
var arr_2 = ["w", [5], "Y"->lc];

arr_1 - arr_2 -> to_s -> say;

#
## joining two arrays
#

["a", "b", "c"] + ["d", "e", "f"] -> to_s -> say;

#####################################################


#
## Regular expressions
#

/TEST/i -> matches("For testing.")->to_s->say;      # true
/[123]/ =~ "one two three" -> to_s->say;            # false

"--string--" =~ /(\w+)/ -> to_s -> say;             # true

var regex = /^\d+ \w+ \d+$/;
"03 May 2013" =~ regex -> to_s->say;                # true
regex -> to_s -> say;                               # prints the regex

/item/ =~ ["str", [123, ["w", "item", "x"], 6], "boo"] -> to_s -> say;    # matches 'item' in nested array

CODE

require Sidef::Parser;
my $parser = Sidef::Parser->new();
my ($struct, $pos) = $parser->parse_script(code => $code);

#use Data::Dump qw(pp);
#pp $struct;

require Sidef::Exec;
my $executer = Sidef::Exec->new();
$executer->execute(struct => $struct);

=cut
    {
      call => [{ name => "sqrt" }, { name => "to_s" }, { name => "print" }],
      self => bless(do{\(my $o = 81)}, "Sidef::Types::Number::Integer"),
    },
=cut
