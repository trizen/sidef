#!/usr/bin/perl

# This script will require Lexer.pm
# and execute the returned data struct.

use 5.014;
use strict;
use warnings;

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (qr/^-/ ~~ \@ARGV) {
    getopts('E:', \%args);
}

# It can be executed as:
#   perl sidef -E '"test"->say'

my $code = exists $args{E} ? $args{E} : <<'CODE';

###################################
# Error testing
###################################
# +->say;      # Invalid object type!
# 3->5;        # Invalid method name!
# var->say;    # Attempt to use an uninitialized variable: <var>
###################################


###################################
# Code testing
###################################

###############################################
##### NEW WAY TO INITIALIZE THE VARIABLES #####
###############################################
#
# optional parentheses for arguments
#
###############################################

var x = "RaNdOm StRiNg"->lc;   # WRONG!!!
var y = ("RaNdOm StRiNg"->lc); # RIGHT!!!
var z = "\LRaNdOm StRiNg";     # Also, right.

#
## Single-quoted string to double-quoted string
#

var single = 'this is a test -- $y -- \n';
single->say;
(single->to_sd)->print;

# -----------------------------------------------

x->say;     # prints 'RaNdOm StRiNg'
y->say;     # prints 'random string'

var name = "Ioana";       # initialize variable "name"

"Hello, $name! How are you? :)\n"->print;
name->uc->say;

6+4/2->to_s->say;       # WRONG!!! Prints 5
6+(4/2)->to_s->say;     # RIGHT!!! Prints 8

12/3*4->to_s->say;      # Prints 16

###############################################
################# OTHER STUFF #################
###############################################

var init = "^_^ Sidef ^_^"->say;  # assings to variable 'init', and prints it
init->uc->say;                    # upper cases the variable 'init', and prints it again

"\n\uvariable interpolation ==> \L$init\\\\\E <== is Working\n"->say;

var hello = "Hello, World!";      # assign a string value to variable 'hello'
hello->say;                       # prints "Hello, World!" from var 'hello'

hello = ("Goodbye, World!\n");    # assign another string to variable 'hello'
hello->print;                     # prints the last assigned string.

var diff = (43-23);               # assign value to 'diff'
diff->to_s->say;                  # print the value stored into 'diff' (20)

(42 / ( 3/(1.0) ) )->to_s->say;   # prints 14

24 -> / (6)->to_s->say;           # prints 4 ( "/" is a method! )

((((((60+(40)))))))->to_s->say;   # prints 100

((42-(4.3*(3)))/(6))->to_s->say;  # prints 4.85

-81->abs->sqrt->to_s->say;        # prints 9

10/(3)->to_s->say;                # prints 3.3333333333333

24/(18*(3/(1)))->to_s->say;       # prints 0.444444444444444

"StRinG"->lc->uc->say;            # prints STRING

44.2->int->log10->to_s->say;      # prints 1.64345267648619

###################################

CODE

require Sidef::Lexer;
my $lexer = Sidef::Lexer->new();
my ($struct, $pos) = $lexer->parse_script(code => $code);

#use Data::Dump qw(pp);
#pp $struct;

=cut
    {
      call => [{ name => "sqrt" }, { name => "to_s" }, { name => "print" }],
      self => bless(do{\(my $o = 81)}, "Sidef::Types::Number::Integer"),
    },
=cut

my %variables;

sub interpolate {
    my (%opt) = @_;

    my $self = $opt{self};

    ${$self} =~ s{\$([a-zA-Z_]\w*)\b}{
                exists $variables{$opt{class}}{$1}
                    ? $variables{$opt{class}}{$1}
                    : do{
                        warn "Use of uninitialized variable <$1> in double quoted string!\n";
                        q{};
                    };
        }eg;

    $self->apply_escapes;
}

sub execute_expr {
    my (%opt) = @_;

    my $expr = $opt{'expr'};

    if (exists $expr->{self}) {

        my $self = $expr->{self};
        if (ref $self eq 'HASH') {
            ($self) = execute(struct => $self);
        }

        if (ref $self eq 'Sidef::Types::String::Double') {
            interpolate(self => $self, class => $opt{class});
        }

        if (exists $expr->{call}) {
            foreach my $call (@{$expr->{call}}) {

                my @arguments;
                my $method = $call->{name};

                if (exists $call->{arg}) {

                    foreach my $arg (@{$call->{arg}}) {
                        if (ref $arg eq 'HASH') {
                            push @arguments, execute(struct => $arg);
                        }
                        else {
                            push @arguments, $arg;
                        }
                    }

                    foreach my $obj (@arguments) {

                        if (ref $obj eq 'Sidef::Types::String::Double') {
                            interpolate(self => $obj, class => $opt{class});
                        }
                    }

                    my $value = $self->$method(@arguments);
                    if (ref $self eq 'Sidef::Variable::Variable') {
                        $variables{$opt{class}}{$self->get_name} = $value;
                    }
                    $self = $value;

                }
                else {

                    if (ref $self eq 'Sidef::Variable::Variable') {
                        my $value = $self->get_value;
                        $variables{$opt{class}}{$self->get_name} = $value;
                        $self = $value;
                    }

                    $self = $self->$method;
                }
            }
        }

        return $self;
    }
    else {
        die "Struct error!\n";
    }
}

sub execute {
    my (%opt) = @_;

    my $struct = $opt{'struct'};

    my @results;
    foreach my $key (keys %{$struct}) {
        foreach my $expr (@{$struct->{$key}}) {
            push @results, execute_expr(class => $key, expr => $expr);
        }
    }

    return @results;
}

execute(struct => $struct);
