#!/usr/bin/perl

use utf8;
use 5.014;
use Encode::Locale qw();

BEGIN {    # support for running sidef locally from everywhere
    require File::Spec;
    require File::Basename;
    unshift @INC,
      File::Spec->catdir(
                         File::Basename::dirname(
                                                   File::Spec->file_name_is_absolute(__FILE__)
                                                 ? __FILE__
                                                 : File::Spec->rel2abs(__FILE__)
                                                ),
                         File::Spec->updir,
                         'lib'
                        );
}

binmode STDIN,  ":encoding(console_in)"  if (-t STDIN);
binmode STDOUT, ":encoding(console_out)" if (-t STDOUT);
binmode STDERR, ":encoding(console_out)" if (-t STDERR and $^P == 0);    # to work under Devel::* modules

require Sidef::Init;

my $name    = 'Sidef';
my $version = $Sidef::VERSION;

my %args;
if ($#ARGV != -1 and chr ord $ARGV[0] eq '-') {
    require Getopt::Std;
    Getopt::Std::getopts('E:d:Dho:ivHN:n:WwcM:S', \%args);
}

# Help
if (defined $args{h}) {
    output_usage();
    exit 0;
}

# Version
if (defined $args{v}) {
    output_version();
    exit 0;
}

# Warnings
if (defined $args{w}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::cluck(@_);
    };
}
elsif (defined $args{W}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::confess(@_);
    };
}

# Number types
if (defined(my $type = $args{N})) {
    if ($type eq 'fast' or $type eq 'perl') {
        require Sidef::Types::Number::NumberFast;
    }
    elsif ($type eq 'rat') {
        require Sidef::Types::Number::NumberRat;
    }
    elsif ($type eq 'int') {
        require Sidef::Types::Number::NumberInt;
    }
    elsif ($type eq 'big' or $type eq 'float') {
        ## default
    }
    else {
        die "Invalid value '${type}' for option '-N'!";
    }
}

# Backend for Math::BigInt
if (defined(my $type = $args{n})) {
    require Math::BigInt;
    Math::BigInt->import(lib => $type);
}

# Memoization
if (defined(my $types = $args{M})) {
    memoize_types($types);
}

# Code from a dumped parse-tree
if (defined $args{d}) {
    require Math::BigFloat;
    Math::BigFloat->import;
    my $struct = do($args{d})
      || die "Can't load the data structure from file '$args{d}': $!\n";
    execute_struct($struct);
}

# Interactive help
elsif (defined $args{H}) {
    help_interactive();
}

# Interactive coding
elsif (defined $args{i}) {
    code_interactive();
}
else {
    my $script_name = '-';

    my $code = exists($args{E})
      ? do {
        defined($args{E}) || die "No code specified for -E.\n";
        $script_name = '-E';
        Encode::decode(locale => $args{E});
      }
      : defined($ARGV[0]) && (-f $ARGV[0]) ? do {
        $script_name = shift @ARGV;

        open my $fh, '<:utf8', $script_name
          or die qq{Can't open sidef script "$script_name": $!\n};

        local $/;
        <$fh>;
      }
      : do { local $/; <> };

    $code // exit 2;
    my $parser = Sidef::Parser->new(
                                    file_name   => $script_name,
                                    script_name => $script_name,
                                    strict      => !$args{S},
                                   );
    my $struct = $parser->parse_script(code => $code);

    # Dump the data structure
    if (defined $args{D}) {
        dump_structure($struct);
    }

    # Compile the struct to a Perl program
    elsif (defined $args{c}) {
        compile_to_perl($struct);
    }

    # Execute the struct
    else {
        execute_struct($struct);
    }
}

#
## Subroutines
#

sub execute_struct {
    my ($struct) = @_;
    Sidef::Types::Block::Code->new($struct)->run;
}

sub output_usage {
    my %switches = (
                    '-i'             => 'interactive mode',
                    '-c'             => 'compile the code as a stand-alone perl program',
                    '-d dumped_file' => 'execute a dumped file',
                    '-D'             => 'dump the data structure of a program',
                    '-o output_file' => 'file where to dump the output',
                    '-E program'     => 'one line of program',
                    '-H'             => 'interactive help',
                    '-N type'        => ['use a specific implementation for numbers', 'valid types: fast, big, int, rat'],
                    '-n type'        => ['try to use a specific backend for Math::BigInt', 'valid types: GMP, Pari, FastCalc'],
                    '-M type,type'   => ['memoize some expensive method calls', 'valid types: str, num, block, all'],
                    '-S'             => 'disable strictures and ignore any errors',
                    '-v'             => 'print version number and exit',
                    '-w'             => 'enable warnings with stack backtrace',
                    '-W'             => 'make warnings fatal (with stack backtrace)',
                   );

    require File::Basename;
    my $basename = File::Basename::basename($0);

    print <<"USAGE";

Usage: $basename [switches] [--] [programfile] [arguments]

USAGE

    require List::Util;
    my $max_width = List::Util::max(map { length } keys %switches);
    $max_width += 4;

    foreach my $key (sort { lc($a) cmp lc($b) or $b cmp $a } keys %switches) {
        if (ref $switches{$key} eq 'ARRAY') {
            printf "  %-${max_width}s%s\n", $key, $switches{$key}[0];
            foreach my $i (1 .. $#{$switches{$key}}) {
                printf "  %-${max_width}s%s\n", '', $switches{$key}[$i];
            }
        }
        else {
            printf "  %-${max_width}s%s\n", $key, $switches{$key};
        }
    }

    print <<"END";

Run '$basename -H' for interactive help.

END
}

sub output_version {
    print "$name $version\n";
}

sub help_interactive {

    my %keywords = (
                    if   => 'Sidef::Types::Bool::If',
                    '\\' => 'Sidef::Variable::Ref',
                    '*'  => 'Sidef::Variable::Ref',
                   );

    require Term::ReadLine;
    my $term = Term::ReadLine->new("$name $version -- help interactive mode");

    print <<"HELP";
Welcome to $name $version!  This is the interactive help utility.

Enter the name of any object, keyword, or topic to get help on writing
$name programs and using $name modules.  To quit this help utility, just
type "quit".

HELP

    {
        my $line = $term->readline('help> ') // do { print "\n"; return };

        if ($line eq 'quit' or $line eq 'q') {
            return;
        }

        my $parser = Sidef::Parser->new(
                                        file_name   => '-H',
                                        script_name => '-H',
                                        strict      => !$args{S},
                                       );
        my $struct = eval { $parser->parse_script(code => $line) };

        if ($@) {
            warn $@;
            redo;
        }

        my @refs = exists($keywords{$line}) ? $keywords{$line} : (map { ref($_) } execute_struct($struct));

        foreach my $ref (@refs) {
            $ref eq '' && do { warn "Not an object!\n"; next };
            system -e '/usr/bin/man' ? '/usr/bin/man' : 'perldoc', $ref;
        }

        redo;
    }
}

sub code_interactive {
    require Term::ReadLine;
    my $term = Term::ReadLine->new("$name $version -- interactive mode");
    my $parser = Sidef::Parser->new(
                                    file_name   => '-i',
                                    script_name => '-i',
                                    strict      => !$args{S},
                                   );

    print qq{$name $version on $^O\n};
    print qq{Type "help", "copyright" or "license" for more information.\n};

    {
        my $line = $term->readline('>>> ') // do { print "\n"; exit };

        if ($line eq 'help') {
            help_interactive();
            redo;
        }
        elsif ($line eq 'q' or $line eq 'quit') {
            exit;
        }
        elsif ($line eq 'copyright') {
            print <<'EOT';
Copyright © 2013 Daniel Șuteu, Ioana Fălcușan
Copyright © 2014 Daniel Șuteu
All Rights Reserved.
EOT
            redo;
        }
        elsif ($line eq 'license') {
            print <<'EOT';

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

EOT
            redo;
        }

        my $struct = eval { $parser->parse_script(code => $line) };

        $@ && do {
            warn $@;
            $parser = Sidef::Parser->new(
                                         file_name   => '-i',
                                         script_name => '-i',
                                         strict      => !$args{S},
                                        );
            redo;
        };

        say eval { $_->can('dump') } ? $_->dump : $_ for execute_struct($struct);
        redo;
    }
}

sub dump_structure {
    my ($struct) = @_;

    eval { require Data::Dump };

    if ($@) {
        die "Data::Dump module is not installed!\n";
    }
    else {
        my $out_fh = \*STDOUT;

        if (defined $args{o}) {
            open $out_fh, '>:utf8', $args{o}
              or die "Can't open file '$args{o}' for write: $!\n";
        }

        print {$out_fh} Data::Dump::pp($struct);
    }
}

sub memoize_types {
    my ($types) = @_;

    my @types =
      $types eq 'all'
      ? ()
      : split(/\s*,\s*/, $types);

    my %known_types;
    {
        no strict 'refs';

        # Init
        $known_types{_init_} = sub {
            require Memoize;

            my $package = 'Sidef::Convert::Convert';
            foreach my $method (
                                qw(
                                stringify
                                )
              ) {
                Memoize::memoize($package . '::' . $method);
            }
        };

        # Number methods
        $known_types{num} = sub {
            my $package = 'Sidef::Types::Number::Number';

            my %ignore;
            @ignore{
                qw(
                  ISA
                  BEGIN
                  new
                  newInt
                  new_int
                  )
            } = ();

            foreach my $method (keys %{$package . '::'}) {
                next if exists $ignore{$method};
                Memoize::memoize($package . '::' . $method);
            }
        };

        # String methods
        $known_types{str} = sub {
            my $package = 'Sidef::Types::String::String';

            my %ignore;
            @ignore{
                qw(
                  ISA
                  BEGIN
                  __ANON__
                  a
                  b
                  new
                  say
                  print
                  println
                  printlnf
                  printf
                  die
                  warn
                  glob
                  eval
                  parse
                  apply_escapes
                  applyEscapes
                  dump
                  split
                  match
                  matches
                  gmatch
                  gmatches
                  =~
                  )
            } = ();

            foreach my $method (keys %{$package . '::'}) {
                next if exists $ignore{$method};
                Memoize::memoize($package . '::' . $method);
            }
        };

        # Block methods
        $known_types{block} = sub {
            my $package = 'Sidef::Types::Block::Code';
            foreach my $method ('call') {
                Memoize::memoize($package . '::' . $method);
            }
        };
    }

    # Get the valid types
    my @valid_types = @types
      ? (
        grep {
            exists $known_types{$_} || do {
                die "Invalid value '$_' for option '-M'!";
                0;
              }
          } @types
        )
      : (grep { $_ ne '_init_' } keys %known_types);

    # Init only if we have some valid types
    if (@valid_types) {
        $known_types{_init_}();
    }

    # Memoize each category
    foreach my $type (@valid_types) {
        $known_types{$type}();
    }
}

sub compile_to_perl {
    my ($struct) = @_;

    eval { require Data::Dump };

    if ($@) {
        die "Data::Dump module is not installed!";
    }
    else {
        require File::Basename;
        my $path = File::Basename::dirname($INC{'Sidef.pm'});

        my $package_content = <<"HEAD";
#!$^X

eval 'exec $^X  -S \$0 \${1+"\$@"}'
    if 0; # not running under some shell

use utf8;
use 5.014;
use warnings;

# For `inf` and `nan` barewords
no strict 'subs';
no warnings 'reserved';

use Encode::Locale qw();
use File::Temp qw(tempdir);
use File::Path qw(make_path);
use File::Spec::Functions qw(catdir catfile);

my \$DIR;
use lib \$DIR = tempdir(CLEANUP => 1);

binmode STDIN,  ":encoding(console_in)"  if (-t STDIN);
binmode STDOUT, ":encoding(console_out)" if (-t STDOUT);
binmode STDERR, ":encoding(console_out)" if (-t STDERR and \$^P == 0);    # to work under Devel::* modules

foreach my \$mod (
HEAD

        require File::Find;
        File::Find::find(
            {
             no_chdir => 1,
             wanted   => sub {
                 if (/\.pm\z/ and -f) {

                     return if m{\bSidef\W+Init\b};

                     local $/;
                     open my $fh, '<:utf8', $_
                       or die "Can't open file `$_' for reading: $!";

                     my $token = tr/A-Za-z0-9/_/cr;

                     $package_content .= qq{<<'${token}',\n};
                     $package_content .= <$fh>;
                     $package_content .= "\n$token\n";

                     close $fh;
                 }
               }
            } => $path
        );

        $package_content .= <<"FOOT";
) {
    if (\$mod =~ /^(?>##\\h*)?package\\h+([\\w:]+)/) {
        my \@parts = split(/::/, \$1);

        my \$name = pop \@parts;
        my \$dir = catdir(\$DIR, \@parts);

        if (\$#parts != -1 and not -d \$dir) {
            make_path(\$dir)
                or die qq{ERROR: Can't create directory "\$dir": \$!};
        }

        my \$filename = catfile(\$dir, \$name . '.pm');

        open my \$fh, '>:utf8', \$filename
            or die qq{ERROR: Can't create file "\$filename": \$!};

        print {\$fh} \$mod;

        close \$fh
            or die qq{ERROR: Can't close file "\$filename": \$!};
    }
    else {
        die qq{ERROR: can't get the package name!};
    }
}

FOOT

        if (exists $INC{'Sidef/Init.pm'}) {
            my $filename = $INC{'Sidef/Init.pm'};

            local $/;
            open my $fh, '<:utf8', $filename
              or die "Can't open file `$filename' for reading: $!";

            $package_content .= <$fh>;
            $package_content .= "use Math::BigFloat;\n";

            if (defined(my $type = $args{N})) {
                if ($type eq 'fast' or $type eq 'perl') {
                    $package_content .= "require Sidef::Types::Number::NumberFast;\n";
                }
                elsif ($type eq 'rat') {
                    $package_content .= "require Sidef::Types::Number::NumberRat;\n";
                }
                elsif ($type eq 'int') {
                    $package_content .= "require Sidef::Types::Number::NumberInt;\n";
                }
            }

            close $fh;
        }
        else {
            die "ERROR: Can't find the `Sidef::Init' module!\n";
        }

        my $out_fh = \*STDOUT;

        if (defined $args{o}) {
            open $out_fh, '>:utf8', $args{o}
              or die "Can't open file '$args{o}' for write: $!";
        }

        print {$out_fh} $package_content;

        print {$out_fh} "\nmy \$struct = ";
        print {$out_fh} Data::Dump::pp($struct);
        print {$out_fh} ";\n";

        print {$out_fh} <<"EXEC";

#
## Execute the data structure
#

Sidef::Exec->new->execute(\$struct);
EXEC
    }
}
